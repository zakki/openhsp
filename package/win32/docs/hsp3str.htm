<HTML lang="ja">
<HEAD><TITLE>HSP ver3 (Hot Soup Processor) TIPS</TITLE>
		<link href="../main.css" rel="stylesheet" type="text/css" media="all">
	</HEAD>
<BODY TEXT="#202020" BGCOLOR="#f0e0d0" VLINK="#606060" LINK="#000000">
<div class="body">
<div class="section">
<div class="head"><A NAME="top" class="head">HSP : Hot Soup Processor ver3.1 / onion software 1997-2007(c)</A></div>
</div>
<HR>

<P><IMG SRC="hsp3ttl.jpg" BORDER=0></P>
<div class="section">
<H2>
<FONT COLOR="#504030">
HSP ver3文字列のひみつ(TIPS)</FONT>
</H2>
<BR><BR>


<H3>はじめに</H3>
<P>
HSPでは、数値型、文字列型などの型を変数の内容として保持することができます。
このドキュメントでは、その中でも文字列型がどのようにHSPで処理されているかを説明しながら、
それぞれの命令の詳細と、その応用についての説明をしています。
文字列の取り扱いを理解することで、より細かく文字列の操作を行なうことができるはずです。
また、メモリ管理やファイルの扱いに関係する部分もあるので、知っておくときっと役に立つ時が
来るでしょう。
</P>
<BR>


<H3>文字列の基本
</H3>
<P>
まず、HSPでの文字列の取り扱いの基本をおさらいしておきましょう。
文字列とは、"(ダブルクォーテーション)で囲まれた、文字の集合体です。
HSPでは、メッセージの表示や、ファイル名などあらゆる場面で文字列を使用します。
たとえば、
<UL><PRE><B>mes "TEST MESSAGE"
</B></PRE></UL>
という命令では、「"」で囲まれた「TEST MESSAGE」
という文字列を画面に表示します。また、変数に文字列を記憶させておくこともできます。
たとえば、「a="TEST MESSAGE"」のように書けば、変数aに「TEST MESSAGE」という文字列が
記憶されます。そうすれば、「mes a」のように文字列を指定するかわりに変数名を指定
して、変数に記憶されている文字列をパラメータとして使うことができるようになります。
<BR>
以上は基本ですが、この応用として文字列に式を加えることができるようになっています。
<BR>
たとえば、
<UL><PRE><B>a="TEST"+" MESSAGE"</B></PRE></UL>
上の例では、「TEST」という文字列と、「 MESSAGE」という文字列を「+」で足し算しています。
数値の計算ならば、加算されるところですが、文字列を足し算した場合は、文字列が連結されます。
つまり、２つの文字列をつなげて「TEST MESSAGE」という文字列になるのです。
文字列で使える式は、足し算のみですが「a="ABC"+"DEF"+"GHI"」のようにいくつも繋げることが
できますし、「a="ABC"+b+"DEF"+c」のように間に変数をはさむことも可能です。
ですから、
<UL><PRE><B>a="TEST"
b=" AND "
c="MESSAGE"
print a+b+c
</B></PRE></UL>
のようにすると、３つの変数の内容が連結されて「TEST AND MESSAGE」という文字列が画面に
表示されます。もしこれが、文字列型の変数でなく、数値が記憶されている数値型変数を途中で
足し算した場合には、どうなるのでしょうか? HSPでは、次のようなお約束があります。

<P><CENTER><B>
「文字列型」に「数値型」を足し算した場合には、「数値」を文字列にして連結される。<BR>
「数値型」に「文字列型」を足し算した場合には、「文字列」を数値にして加算される。<BR>
</B></CENTER></P>

つまり、計算式で最初の項になっている型に自動的に合わせてくれるということです。
ですから、
<UL><PRE><B>a="TEST "
b=12345
c=" MESSAGE"
print a+b+c
</B></PRE></UL>
のように数値型の変数が間にあっても、「TEST 12345 MESSAGE」という表示になり、これは
あくまで文字列として扱われます。
</P>
<BR>


<H3>文字列とは何か?
</H3>
<P>
HSPでは文字列をどのように管理しているのでしょうか?
前にも言ったように、文字列は長さ不定の文字の集合体です。
文字列型変数には、メモリの許す限り無制限の文字数を記憶することができます。
ここで、「文字列」と「バッファ」の関係を知っておくと、文字列の扱いが
よりスッキリとします。
<BR>
HSPでは、文字列の1文字1文字を「コード」という数値で扱って管理しています。
これは、どんなコンピュータでも内部では数値で管理されているためです。
下の表を見てみてください。
</p>
<BR><BR>
<table align=center border=0 cellspacing=0 cellpadding=0>
<tr class="glay">
<td width=10%>コード(10進数)</td>
<td width=10%>コード(16進数)</td>
<th width=5%>0</th>
<th width=5%>1</th>
<th width=5%>2</th>
<th width=5%>3</th>
<th width=5%>4</th>
<th width=5%>5</th>
<th width=5%>6</th>
<th width=5%>7</th>
<th width=5%>8</th>
<th width=5%>9</th>
<th width=5%>a</th>
<th width=5%>b</th>
<th width=5%>c</th>
<th width=5%>d</th>
<th width=5%>e</th>
<th width=5%>f</th>
</tr>

<tr class="white">
<td bgcolor="#ccffff" width=10%>32</td>
<td bgcolor="#ccffff" width=10%>$20</td>
<th bgcolor="#ccffff" width=5%>　</th>
<th bgcolor="#ccffff" width=5%>!</th>
<th bgcolor="#ccffff" width=5%>"</th>
<th bgcolor="#ccffff" width=5%>#</th>
<th bgcolor="#ccffff" width=5%>$</th>
<th bgcolor="#ccffff" width=5%>%</th>
<th bgcolor="#ccffff" width=5%>&</th>
<th bgcolor="#ccffff" width=5%>'</th>
<th bgcolor="#ccffff" width=5%>(</th>
<th bgcolor="#ccffff" width=5%>)</th>
<th bgcolor="#ccffff" width=5%>*</th>
<th bgcolor="#ccffff" width=5%>+</th>
<th bgcolor="#ccffff" width=5%>,</th>
<th bgcolor="#ccffff" width=5%>-</th>
<th bgcolor="#ccffff" width=5%>.</th>
<th bgcolor="#ccffff" width=5%>/</th>
</tr>

<tr class="white">
<td bgcolor="#ccffff" width=10%>48</td>
<td bgcolor="#ccffff" width=10%>$30</td>
<th bgcolor="#ccffff" width=5%>0</th>
<th bgcolor="#ccffff" width=5%>1</th>
<th bgcolor="#ccffff" width=5%>2</th>
<th bgcolor="#ccffff" width=5%>3</th>
<th bgcolor="#ccffff" width=5%>4</th>
<th bgcolor="#ccffff" width=5%>5</th>
<th bgcolor="#ccffff" width=5%>6</th>
<th bgcolor="#ccffff" width=5%>7</th>
<th bgcolor="#ccffff" width=5%>8</th>
<th bgcolor="#ccffff" width=5%>9</th>
<th bgcolor="#ccffff" width=5%>:</th>
<th bgcolor="#ccffff" width=5%>;</th>
<th bgcolor="#ccffff" width=5%>&lt</th>
<th bgcolor="#ccffff" width=5%>=</th>
<th bgcolor="#ccffff" width=5%>&gt</th>
<th bgcolor="#ccffff" width=5%>?</th>
</tr>

<tr class="white">
<td bgcolor="#ccffff" width=10%>64</td>
<td bgcolor="#ccffff" width=10%>$40</td>
<th bgcolor="#ccffff" width=5%>@</th>
<th bgcolor="#ccffff" width=5%>A</th>
<th bgcolor="#ccffff" width=5%>B</th>
<th bgcolor="#ccffff" width=5%>C</th>
<th bgcolor="#ccffff" width=5%>D</th>
<th bgcolor="#ccffff" width=5%>E</th>
<th bgcolor="#ccffff" width=5%>F</th>
<th bgcolor="#ccffff" width=5%>G</th>
<th bgcolor="#ccffff" width=5%>H</th>
<th bgcolor="#ccffff" width=5%>I</th>
<th bgcolor="#ccffff" width=5%>J</th>
<th bgcolor="#ccffff" width=5%>K</th>
<th bgcolor="#ccffff" width=5%>L</th>
<th bgcolor="#ccffff" width=5%>M</th>
<th bgcolor="#ccffff" width=5%>N</th>
<th bgcolor="#ccffff" width=5%>O</th>
</tr>

<tr class="white">
<td bgcolor="#ccffff" width=10%>80</td>
<td bgcolor="#ccffff" width=10%>$50</td>
<th bgcolor="#ccffff" width=5%>P</th>
<th bgcolor="#ccffff" width=5%>Q</th>
<th bgcolor="#ccffff" width=5%>R</th>
<th bgcolor="#ccffff" width=5%>S</th>
<th bgcolor="#ccffff" width=5%>T</th>
<th bgcolor="#ccffff" width=5%>U</th>
<th bgcolor="#ccffff" width=5%>V</th>
<th bgcolor="#ccffff" width=5%>W</th>
<th bgcolor="#ccffff" width=5%>X</th>
<th bgcolor="#ccffff" width=5%>Y</th>
<th bgcolor="#ccffff" width=5%>Z</th>
<th bgcolor="#ccffff" width=5%>[</th>
<th bgcolor="#ccffff" width=5%>\</th>
<th bgcolor="#ccffff" width=5%>]</th>
<th bgcolor="#ccffff" width=5%>^</th>
<th bgcolor="#ccffff" width=5%>_</th>
</tr>

<tr class="white">
<td bgcolor="#ccffff" width=10%>96</td>
<td bgcolor="#ccffff" width=10%>$60</td>
<th bgcolor="#ccffff" width=5%>`</th>
<th bgcolor="#ccffff" width=5%>a</th>
<th bgcolor="#ccffff" width=5%>b</th>
<th bgcolor="#ccffff" width=5%>c</th>
<th bgcolor="#ccffff" width=5%>d</th>
<th bgcolor="#ccffff" width=5%>e</th>
<th bgcolor="#ccffff" width=5%>f</th>
<th bgcolor="#ccffff" width=5%>g</th>
<th bgcolor="#ccffff" width=5%>h</th>
<th bgcolor="#ccffff" width=5%>i</th>
<th bgcolor="#ccffff" width=5%>j</th>
<th bgcolor="#ccffff" width=5%>k</th>
<th bgcolor="#ccffff" width=5%>l</th>
<th bgcolor="#ccffff" width=5%>m</th>
<th bgcolor="#ccffff" width=5%>n</th>
<th bgcolor="#ccffff" width=5%>o</th>
</tr>

<tr class="white">
<td bgcolor="#ccffff" width=10%>112</td>
<td bgcolor="#ccffff" width=10%>$70</td>
<th bgcolor="#ccffff" width=5%>p</th>
<th bgcolor="#ccffff" width=5%>q</th>
<th bgcolor="#ccffff" width=5%>r</th>
<th bgcolor="#ccffff" width=5%>s</th>
<th bgcolor="#ccffff" width=5%>t</th>
<th bgcolor="#ccffff" width=5%>u</th>
<th bgcolor="#ccffff" width=5%>v</th>
<th bgcolor="#ccffff" width=5%>w</th>
<th bgcolor="#ccffff" width=5%>x</th>
<th bgcolor="#ccffff" width=5%>y</th>
<th bgcolor="#ccffff" width=5%>z</th>
<th bgcolor="#ccffff" width=5%>{</th>
<th bgcolor="#ccffff" width=5%>|</th>
<th bgcolor="#ccffff" width=5%>}</th>
<th bgcolor="#ccffff" width=5%>~</th>
<th bgcolor="#ccffff" width=5%>　</th>
</tr>
</table>
<BR>

<p>
これは、「アスキーコード表」と呼ばれているものです。
どんな文字にも、それに対応する数値(コード)があります。その中でも標準的に使われている、
半角のアルファベットや記号だけを抜き出したものをアスキーコード
( ASCII : American Standard Code for Information Interchange )
といいます。英語ではこれで十分なのですが、日本語ではこの他に全角の文字が多数あり、
それぞれにやはりコードがあります。
これは何も難しい概念ではなくて、単純に「A」という文字はコード65(10進数)、「$」は
36(10進数)というように数字に直すことができるよ、というだけの話です。
この表の見かたは、たとえば「@」であれば左の「コード」にある数値の通り「64」になり、
以後右にずれるたびに１づつふえていきます。つまり、「A」は65、「B」は66…というぐあいです。
「コード」のところに10進数と、16進数が書いてありますが、コンピュータの世界では16進数だと
区切りがいいということで、HSPでは10進数でもかまいませんし、16進数でももちろんOKです。
(HSPで16進数は「$48」など$を頭につけて表記します)
ですから、「N」は10進数では78、16進数では$6eになります。混乱すると困るので、ここでは
特に表記がない限り、コードは10進数で扱っていきます。
<BR>
ちなみに、スペースキーを押して出てくるスペースは、コード32になります。
他にスペースになっている場所もありますが、通常は使われません。
<BR>
さて、文字列は、このコードの集まりだと考えることができます。
コードは、0から255までの数値になります。つまり256種類の文字を表わすことができるという
わけです。しかし、日本語の漢字などを含めると膨大な量になり、とても256種類では足りません。
そこで、HSPでは、日本語はコードを２つ使用して256種類×256種類＝65536種類(そんなにないけど)ぶんの
コードを使うことにしています。
日本語の文字が全角と呼ばれ、英文字が半角と呼ばれるのは、
英文字(アスキーコード)が日本語文字に対して半分サイズのコードだからなのです。
日本語コードの表わしかたには色々な種類がありますが、HSPが使用しているものは、
シフトJIS(SJIS)と呼ばれているものです。このドキュメントでも、シフトJISに基づいた説明を行なっています。
<BR>
まずは、「文字を表わすコードが、いくつか並んでいるものが文字列」なのだということを
ここでは覚えておいてください。これが何の役に立つか、もうすぐわかるはずですよ。
</P>
<BR>


<H3>文字列とバッファ
</H3>
<P>
文字は、0〜255までの数値で表わされるコードにすることができることがわかりました。
この、256種類という数字はコンピュータの世界ではよく出てくる1バイト(byte)という単位に
なります。バイトとは、数値をコンピュータのメモリに記憶させる際の基本となる単位で、
1バイトには、0〜255までの数値を記憶させておくことができます。１メガバイトのメモリは、
バイトに直すと、ざっと1,000,000バイトですからごくごく小さな単位です。
<BR>
こんなハード寄りの話を出したのは、難しくしたいためじゃありません。
この1バイト、0〜255までの数値というところでHSPの、poke命令およびpeek命令のことを
思い出してもらいたかったからです。
<BR>
poke命令、peek命令はメモリバッファの読み書きをするための命令で、ちょっと文字列とは
無縁な感じがします。しかしながら、<B>
変数の内容が記憶されている場所もまた、メモリバッファの１つ</B>
なのです。これは知っておくと役に立つ重要な概念です。文字列型変数に記憶されている文字列
の内容や、数値型の変数、そして配列までもがpeek関数、poke命令で読み書き可能である
ということです。同様に、メモリバッファを対象にした命令(bload命令やbsave命令)もすべて
通常の変数に対して使用できます。
<BR>
ここでためしに、
<UL><PRE><B>
a="*"
b=peek(a,0)
mes "b="+b
</B></PRE></UL>
というスクリプトを実行してみてください。変数aに代入された「*」という文字列が記憶されている
バッファから、１バイトを取り出して表示していますが、「*」の文字コードである42という数値
が取り出されています。このように、poke命令、peek関数を使うことで、記憶されている文字列に
対してより細かなアクセスができることになります。
<BR>
これからいよいよ、その細かなアクセスの詳細について説明していきましょう。
</P>
<BR>


<H3>文字列のしくみ
</H3>
<P>
文字列が記憶されているバッファには一定のルールがあります。
まずは、この重要なルールをまず最初に覚えておいてください。
<UL><P><B>
１． 1バイトにつき1文字のコードが連続して置かれている。<BR>
２． 文字列の一番最後は、終わりを示すコードとして0が置かれている。<BR>
</B></UL></P>
この２つのルールさえわかってしまえば、あとはこれに従ってバッファをどういじっても問題
ありません。まず簡単な例として次のようなスクリプトがあったとします。
<UL><PRE><B>a="ABCDE"
</B></PRE></UL>
これが実行されると、変数aの内容が記憶されているバッファは次のようになります。
<BR><BR>
<table align=center border=0 cellspacing=0 cellpadding=0>
<tr class="glay">
<td>A</td>
<td>B</td>
<td>C</td>
<td>D</td>
<td>E</td>
<td>終了コード</td>
</tr>
<tr class="white">
<td>65</td>
<td>66</td>
<td>67</td>
<td>68</td>
<td>69</td>
<td>0</td>
</tr>
</table>
<BR>
文字列「ABCDE」は、バッファの中では「65」「66」「67」「68」「69」「0」という数値に
なって記憶されることになります。peek関数は、バッファの中の好きな場所から１バイト、
データを取り出すことのできる命令です。ヘルプによれば、
<UL><PRE><B>peek(p1,p2)			バッファから1byte読み出し

p1=変数 : バッファを割り当てた変数名 
p2=0〜 : バッファのインデックス(Byte単位) 
</B></PRE></UL>
ということなので、
<UL><PRE><B>a="ABCDE"
b=peek(a,2)
</B></PRE></UL>
とすれば、変数aの３文字目にある文字のコードを読み出すことができます。
なぜ３文字目になるかと言うと、peek命令の2番目のパラメータは、0から始まって1バイト
ごとの指定なので、2を指定した場合は０・１・２の順で3文字目にあたるコードを取り出して
いるためなのです。
<BR>
poke命令は逆にバッファにデータを書き込みための命令です。ヘルプによれば、
<UL><PRE><B>poke p1,p2,p3			バッファに1byte書き込み

p1=変数 : バッファを割り当てた変数名 
p2=0〜 : バッファのインデックス(Byte単位) 
p3=0〜255 : バッファに書き込む値 または 文字列(Byte単位) 
</B></PRE></UL>
ということなので、たとえば、
<UL><PRE><B>a=""
poke a,0,65
poke a,1,66
poke a,2,67
poke a,3,0
mes a
</B></PRE></UL>
とすれば、変数aには何も文字列を代入していないにもかかわらず、バッファに直接データを
書き込んだために、「ABC」という文字列が記憶されています。
忘れてはいけないのは、最後に終わりを示すコードとして0を入れておくことです。
HSPは、0が出てくるまでバッファの内容を文字列として解釈します。もし、0を忘れてしまうと
余計なデータを文字列に加えてしまったり、最悪の場合、一般保護エラーが出るまでメモリを
読み続けてしまいます。
<BR>
この終わりを示すコードを逆手に取って次のようなこともできます。
<UL><PRE><B>a="ABCDEF"
poke a,3,0
mes a
</B></PRE></UL>
このスクリプトでは、変数aに「ABCDEF」という文字列を代入していますが、その後でpoke命令
により、途中に終了コードを書き込まれています。その結果、「ABC」の後に終了コードがある
ためにそこで文字列は終了と判断され、「ABC」という文字列だけしか表示されません。
<BR>
このように、文字列のしくみを理解することで、文字列の各文字に対してのアクセスが
容易になります。
<BR>
バッファの中を読み出したり、書き込んだりする場合には注意しなければならない点があります。
変数バッファに文字列は無制限に代入することができますが、最初から大きなサイズのバッファを
用意するわけにはいきません。そこで、最初は小さな領域を確保しておき、必要に応じて
領域を拡張しています。
<BR>
sdim命令により文字列の宣言を行なう際に、最初に確保する領域サイズを指定することができます。
領域の拡張は自動で行なわれますが、最初から大きなサイズの文字列を使うことがわかっている場合や、
２次元以上の配列を使う場合には指定をしておくといいでしょう。
ただし、256バイトのバッファを確保したとしても、255文字までしか使うことはできません。
最後に終了コード0を入れる場所が必要だからです。「sdim a,256」は、255文字＋終了コード
までは領域を確保するという意味になります。
<BR>
peek関数やpoke命令は、現在確保されている領域内のみにしか使用することができません。
たとえば、「sdim a,256」のように256バイトのバッファを確保していたとすれば、
0〜255の範囲しか利用できないので注意してください。
<BR>
<BR>
文字列の一部を文字コードにして取り出したり、また逆に文字コードを文字列にするようなことは
何かの時にあると便利です。よく使うテンプレートとして次の２つをあげておきます。
<UL><PRE><B>例1: (文字コードを取り出す)
b=peek(a,0)  ; 変数aの最初の文字コードを変数bに代入

例2: (文字コードを文字列にする)
a="_"
b=65
poke a,0,b  ; 文字列型変数aに、変数bの文字コードを入れる
</B></PRE></UL>
例2では、変数bに代入されている数値をpoke命令で文字コードとして書き込んでいます。
これは、変数aの1文字目に上書きされます。変数aは、最初に「_」という1文字だけが代入
されていますが、この「_」はなくなり、新しい文字コードに書き換わります。
文字列の最後にある終わりのコード(0)は、最初の「a="_"」ですでに設定されているので、
もう一度書き込む必要はありません。このような手順で、文字コードを1文字の文字列型変数
に変換することができます。
<BR>
これらの例は、Microsoft系N-BASICを使った人であれば、ASC、CHR$といった関数と
同じような働きと言えば分かりやすいかもしれません。文字コードを扱うことは、
通常あまりないかもしれませんが、いざという時に小回りのきく手段として覚えておくといいでしょう。
<BR>
<BR>
もう１つ便利な例をご紹介しましょう。
peek関数を使えば、文字列の中から任意の場所にある1文字をコードとして取ってくることが
できます。しかし、取り出すのはあくまでコード(数値)でありいちいちアスキーコード表と
てらし合わせるのは面倒です。そんな時に使うと便利なのが「'(シングルクォーテーション)」
による表記です。これは、「'A'」のように1文字を「'」で囲んで使用します。こうすると、
「'A'」は「65」と同じ意味になります。つまり、「'」で囲んだ文字をコードに直してくれる
のです。ですから、
<UL><PRE><B>a="***TEST"
b=peek(a,0)
if b='*' : mes "*がありました"
</B></PRE></UL>
とすれば、変数aの1文字目が「*」のコードかどうかを手軽に調べることができます。
「'」は、文字列を扱う「"(ダブルクォーテーション)」に似ていますが、実際は数値を示す
ので間違えないようにしてください。
<BR>
<BR>
ここで説明した内容を最後に、おさらいしておくと、
<UL><P><B>
１．peek関数で文字列の内容をコードとして取り出すことができる。<BR>
２．poke命令で文字列の一部を指定したコードに書き替えることができる。<BR>
</B></UL></P>
ということになります。
この概念と、文字コードの存在を知っておくだけでもいいと思います。
</P>
<BR>


<H3>テキストファイルのしくみ
</H3>
<P>
メモ帳やテキストエディタなどで開いたり保存したりしているテキストファイルですが、
HSPでもこのテキストファイルを読み込んだり、作成することができるようになっています。
テキストファイルとは何なのでしょうか? 実は、テキストファイルとは文字列の
内容をそのままファイルにしただけのものなのです。
いままで説明してきたように、変数に記憶された文字列はメモリ上のバッファに、コードという
形で記憶されています。この内容をそのままbsave命令でファイルにセーブすると、
テキストファイルができあがります。逆に言えば、テキストファイルの内容は単なる文字列に
ほかならないのです。
<BR>
たとえば、
<UL><PRE><B>a="TEXT FILE."
bsave "test.txt",a
</B></PRE></UL>
のようなスクリプトでも「TEXT FILE.」という内容のテキストファイルを作成できます。
しかし、これだけだとファイルサイズがバッファのサイズと同じになってしまってムダが
できてしまいます。文字列として使用している分だけをファイルにセーブするようにすれば
完璧です。そこで、
<UL><PRE><B>a="TEXT FILE."
size=strlen(a)
bsave "test.txt",a,size
</B></PRE></UL>
上のように、strlen命令を使って文字列の長さを調べてから、そのサイズだけセーブするように
すれば適切な長さのテキストファイルになります。
<BR>
同じ要領で、テキストファイルの読み込みもbload命令で行なうことができます。
たとえば、
<UL><PRE><B>sdim a,32000
bload "test.txt",a
mes a
</B></PRE></UL>
このようなスクリプトになります。最初のsdim命令は、読み込んでくるテキストファイルが
大きいかもしれないので約32000文字分のバッファを確保しています。これで、32000バイトの
ファイルまでは読み込むことが可能です。bload命令でテキストファイルを読み込んで、
最後にmes命令でその内容を表示しています。
sdim命令で、文字列型の変数としてバッファを初期化しているので、mes命令ではバッファの
内容を文字列として単純に表示します。バッファに読み込まれたテキストファイルもまた、
文字列と同じなので、そのままちゃんと表示されるというわけです。
<BR>
<BR>
テキストファイルは、文字列型変数のバッファをファイルにしたものと言ってきましたが、
実は１つだけ異なる部分があります。それは、
<UL><P><CENTER><B>
最後に文字列の終わりを示すコード0が入っていない。
</B></CENTER></UL></P>
という点です。これは、ファイルにセーブされたサイズが、すなわち文字列のサイズということ
なので、終わりを示すコードが必要ないためです。
(ただし、一部のテキストエディタではわかりやすいようにテキストファイルにも終了コード
を入れてくれるものがあります。しかし、これは[EOF]と呼ばれるコードで、0ではなく、
26になります)
<BR>
HSPでテキストファイルを読み込んできた場合には、最後に0を入れる必要があるのに、そのまま
使えています。これには、深ーいわけがあります。
そのわけは、sdim命令のように、変数のバッファが確保された直後は、その内容がすべて
0でクリアされているのです。このバッファに、終了コードの入っていないテキストファイルを
読み込んでも、読み込まれたデータの続きには、必ず終了コードである0が入っているというわけです。
そんなに深いわけでもなかったですね。ですから、一度テキストファイルを読み込んできたバッファに、
もう一度別なテキストファイルを読み込んだ場合には、以前のテキストファイルよりも小さなサイズだった
場合には、以前のデータが残ってしまいます。
そうならないためには、テキストファイルを読み込む前に必ずsdim命令でバッファを
確保するようにして、0でクリアする必要があるのです。
<BR>
実は、テキストファイルを読み込むには、もっと単純な方法があります。
「メモリノートパッド命令」という仕組みを使えば、サイズや終端のコードを気にせず、
テキストファイルを扱うことができます。この方法については、後で説明します。
</P>
<BR>


<H3>複数行文字列のしくみ
</H3>
<P>
HSPが扱う文字列は大きく分けて、1行だけの単純な文字列と、複数行を含む文字列とに分ける
ことができます。この２つは、特に処理の上では違いがありません。単に、スクリプトを
作るユーザーが意識しておけばいいだけのものです。
複数行文字列とは、改行が含まれている文字列のことです。改行とは、それ以降を次の行に
もっていくための、しるしみたいなものです。<BR>
ためしに、
<UL><PRE><B>a="ABC\nDEF"
mes a
</B></PRE></UL>
というスクリプトを実行してみると、
<UL><PRE><B>
ABC
DEF
</B></PRE></UL>
という2行にまたがって、メッセージが表示されます。
これは、変数aの中に「\n」という改行のしるしが含まれているためです。
<BR>
いままで、文字にはコードがあり数値の形で、バッファに記憶されているということを
言ってきましたが、改行はどうなっているのでしょうか。
上の例にあげたスクリプトの場合、変数aの内容はバッファの中では、
<BR><BR>
<table align=center border=0 cellspacing=0 cellpadding=0>
<tr class="glay">
<td>A</td>
<td>B</td>
<td>C</td>
<td>\n</td>
<td>　</td>
<td>D</td>
<td>E</td>
<td>F</td>
<td>終了コード</td>
</tr>
<tr class="white">
<td>65</td>
<td>66</td>
<td>67</td>
<td>13</td>
<td>10</td>
<td>68</td>
<td>69</td>
<td>70</td>
<td>0</td>
</tr>
</table>
<BR>
というデータが入っています。「\n」が改行を示すものですが、その部分は「13」「10」
という２つのコードになっています。そして、これがまさに「改行コード」なのです。
改行コードは、キーボードから入力できないので、HSPではかわりに「\n」という文字で
表わすようにしていますが、実際は「13」と「10」の２つのコードが文字列の中に
置かれています。
<BR>
困ったことに、改行コードにはいくつかの方言があります。MS-DOSやWindowsでは「13」「10」
というコードですが、MacintoshのMacOSでは「13」のみです。また、UNIXでは「10」に
なっています。HSPでは、改行コードとして、MS-DOSやWindowsの「13」「10」の他にも、
MacOSの「13」だけの場合にも対応していますが、UNIXの改行コードには対応していません。
そもそも多くのUNIXでは日本語のコードも違っているので、DOS形式へのコンバーターなどで
あらかじめテキスト全体を変換しておいた方がいいでしょう。
</P>
<BR>


<H3>メモリノートパッド命令のしくみ
</H3>
<P>
改行コードが入ることにより、文字列は非常に便利になりますが、複雑さは増します。
テキストファイルには、当然改行コードが含まれてたくさんの行があるでしょうし、
HSPのmesbox命令による入力ボックスも、改行を入れることができます。
また、dirlist命令や、listbox命令、combox命令で使用する文字列にも改行コードが入って
います。改行コードを入れることにより、たくさんの情報を整理することができる反面、
文字列としての取り扱いはどんどんやりにくくなっていきます。
<BR>
そこでHSPでは、メモリノートパッド命令という一連の命令セットにより改行コードを
含んだ文字列を比較的簡単に扱えるようにしています。複数の行があるテキストを
扱う場合に問題となるのは、1行ごとに何かをチェックしたい場合や、1行単位で文字列を
操作したくなった場合です。この1行単位での仕事では、２つのプロセスに分けると
作業がすっきりとします。つまり、
<UL><P><B>
１．複数行から任意の行の内容だけを取り出す
<BR>
２．取り出した文字列に対してチェックをしたり、加工をする
<BR>
３．必要ならば、それをもとの行に戻す
</B></UL></P>
このように、複数行の文字列データから、1行だけの改行コードを含まない文字列を
取り出してから作業をして、結果をふたたび戻すという手順であれば、改行コードについての
面倒なチェックも必要なくなり効率もよくなります。
そのための命令セットがメモリノートパッド命令です。
これは、以下のような命令から成っています。
<BR><BR>
<table cellspacing="0" align=center border=0 cellpadding=0><tr class="aqua"><td>
命令</td><td>おもな機能</td><td>備考
</td></tr>
<tr class="water"><td>
notesel</td><td>メモリノートパッドとして扱う変数の指定</td><td>　</td></tr><tr class="water"><td>
notemax</td><td>全体の行数を取得</td><td>　</td></tr><tr class="water"><td>
noteload</td><td>テキストファイル読み込み</td><td>　</td></tr><tr class="water"><td>
notesave</td><td>テキストファイル書き出し</td><td>　</td></tr><tr class="water"><td>
noteadd</td><td>指定行に内容追加</td><td>挿入/上書きモードあり
</td></tr><tr class="water"><td>
noteget</td><td>指定行の内容読み出し</td><td>　</td></tr><tr class="water"><td>
notedel</td><td>指定行の削除</td><td>　</td></tr></table><br>
命令がいくつもありますが、使い方は難しくありません。
基本的には、最初に文字列操作の対象となる変数名をnotesel命令で指定します。
それから、もし1行読み出す場合にはnoteget命令を、行の内容を変更・追加する場合には、
noteadd命令を使います。たとえば、複数行ある文字列を含む変数aで、最初の行にある
文字列を取り出したい場合は、
<UL><PRE><B>a="ABC\nDEF"
notesel a
noteget b,0
mes b
</B></PRE></UL>
のようになります。この時、注意しなければならないのは、noteget命令で指定する
行インデックスは0から始まるので、1行目の指定が0になるということです。
そして細かいことですが、noteget命令は読み出す先の変数を必ず文字列型にセットします。
上の例で言うと、変数bがそれまで数値型であってもnoteget命令を実行した後は、
文字列型になるということです。
<BR>
notemaxとrepeat〜loop命令を使うことで、すべての行に対しての処理を効率的に
記述できます。たとえば、
<UL><PRE><B>a="ABC\nDEF\GHI"
notesel a
repeat notemax
noteget b,cnt
mes "["+b+"]"
loop
</B></PRE></UL>
このスクリプトでは、変数aのすべての行の内容をカッコでくくった状態で表示させます。
notemaxは、行がいくつあるかを調べて変数に返すシステム変数として使用することができます。
ここで調べた回数だけ、repeat〜loop命令でループさせます。このループ中は、
システム変数cntが0から順番に数字が上がっていくので、noteget命令で読み出す
行インデックスの指定に、システム変数cntを使えば各行を順番に取り出していけることになります。
<BR>
<BR>
メモリノートパッド命令により、テキストファイルを扱うことも可能です。
noteload命令は、テキストファイルを読み込む場合に、
notesave命令は、テキストファイルを保存する場合に使います。
たとえば、
<UL><PRE><B>a="ABC\nDEF\GHI"
notesel a
notesave "a.txt"
</B></PRE></UL>
このスクリプトでは、変数aに代入されている内容を「a.txt」という名前のテキストファイルとして
保存します。簡単ですね。
<BR>
逆に、テキストファイルを変数に読み込む場合には、以下のように使います。
<UL><PRE><B>notesel a
noteload "a.txt"
mes a
</B></PRE></UL>
noteload命令は、指定されたファイルをnotesel命令で指定された変数に読み込みます。
文字列終端の終了コードや、変数のバッファ領域なども自動的に考慮されるようになっています。
<BR>
</P>
<BR>


<H3>文字列操作関数
</H3>
<P>
HSPには、文字列の検索をするためのinstr関数と、文字列の一部を取り出すためのstrmid関数が
標準で用意されています。
このドキュメントを読むと、同様の処理をpeek命令やpoke命令でも実現できることが
わかると思いますが、そこは当然最初から機能がサポートされていた方がいいに決まってますよね。
この２つの新しい命令は、単純ながら多くの場所で使える便利な命令です。
まず、strmid命令はだいたい以下のようになっています。
<UL><PRE><B>strmid(p1,p2,p3)			文字列の一部を取り出す

p1=変数名  : 取り出すもとの文字列が格納されている変数名
p2=0〜(0)  : 取り出し始めのインデックス
p3=0〜(0)  : 取り出す文字数
</B></PRE></UL>
Microsoft系のN-BASICを使ったことのある人であれば、文字列の取り出しに
LEFT$、RIGHT$、MID$という３つの関数があったのを覚えているかもしれません。
これらは、それぞれ文字列の「左からn文字」「右からn文字」「n1文字目からn2文字」
を取り出して、その内容を返すというものでしたが、strmid関数は、その３つの機能を
合わせ持った命令です。
<BR>
p1に取り出す元の文字列が記憶されている変数名を指定して、
p2で取り出し始める文字インデックス(0から始まる)、p3で取り出す文字数を
指定するというものです。注意しなければいけないのは、p3の文字インデックスは、
1文字目が0になり、2文字目が1…という0からの順番になっているということ。
これで、たとえば変数aの一部を取り出す場合、
<UL><P><B>
「左からn文字」を取り出す場合は、「strmid( a,0,n )」となり、
<BR>
「右からn文字」の場合は、「strmid( a,-1,n )」となり、
<BR>
「n1文字目からn2文字」は、「strmid( a,n1-1,n2 )」
</B></UL></P>
になります。
<BR>
もう１つ追加されたのは、文字列の中に、指定した文字列が含まれているかどうかを
調べるinstr関数です。これはヘルプでは、
<UL><PRE><B>instr(p1,p2,"string")		文字列の検索をする

p1=変数名  : 検索される文字列が格納されている文字列型変数名
p2=0〜(0)  : 検索を始めるインデックス
"string"   : 検索する文字列
</B></PRE></UL>
というようになっています。
p1で指定した文字列型変数の中に、"string"で指定した文字列があるかどうか調べて、
文字インデックスを返します。
結果は数値になるという点に注意してください。文字インデックスでは、
文字列の始まり１文字目を0として、1,2,3...と順番に増えていきます。
(strmid命令で指定するインデックスと同様)。
もし、見つからなかった場合には-1が代入されます。
<BR>
また、p2で調べ始める文字インデックスを指定することができます。(指定を省略
した場合は、最初(0)からになります)
この場合、検索の結果は調べ始めた場所からのインデックスが返されるということに
注意してください。文字列の最初からのインデックスではなくなります。
</P>
<BR>


<H3>日本語文字列のしくみ
</H3>
<P>
いままで説明したことは、とりあえず半角の文字列。アスキーコード表の文字に関しての話です。
HSPで用意された文字列操作に関する命令も、すべて文字の単位は半角文字になっています。
扱う文字列が、英文字だけであれば問題はありません。
しかし、これが日本語の全角文字を含んでいるとちょっとトリッキーになります。
前にも言ったように、日本語は1バイト(256種類)では表わしきれないので、
2バイト使って表現しています。
つまり、英文字2文字分で日本語1文字なのです。しかしこれらは、混在できるようになっている
ために、ちょっと複雑なルールがあります。次のようなルールです。
<UL><P><B>
コードが129〜159か、224〜252の範囲にある場合は、次の1バイトと合わせて1文字の全角コードとなる。
</B></UL></P>
つまり、コードの数値がある範囲にある時だけは、2文字分で１つとする特殊なルールを作ってあるわけです。
これは、WindowsやMS-DOSにおいて有効なルールで、他のOSやインターネット上から持ってきたテキストでは
通用しないことがあります。
このような日本語文字コードのことを普通、「シフトJISコード」と呼んでいます。日本語は、
2バイトで1文字ですから、日本語の文字コードを取り出す場合などはpeek命令を2回行なうか、
wpeek命令を使う必要があります。ただし、wpeek命令は、「$81」「$24」(それぞれ16進数)
という2バイトのコードがあった場合、「$2481」(16進数)のように、2バイトを逆転して
1つの数値にしてしまうので注意が必要です。
<BR>
そんなこんなで、日本語コードを扱うのは英文字よりも少しやっかいです。
ただし、英文字と日本語を混在させないなどの制限をつけてやれば、必ず2バイトで1文字という
法則になり、文字を取り出したり、長さをチェックしたりする時には容易になるでしょう。
</P>
<BR>


<H3>最後に
</H3>
<P>
このドキュメントでは、文字列のしくみを理解することで、より細か効率的に文字列を操作する
方法について説明してきました。
改行コードを含まない文字列に対してのアプローチと、それにメモリノートパッド命令を加える
ことで、複数行に渡る文字列であっても効率的に処理することができるようになると思います。
このドキュメントで、その作業が少しでも楽になってくれれば幸いです。
</P>
<BR>


<BR><BR>
</div>
<HR>
<!--フッター-->
<div class="section">
<table width="620px">
<tr>
<td>
<A HREF="../index.htm" class="foot"><B>[前のメニューに戻る]</B></A><BR>
<A HREF="http://hsp.tv/" class="foot">
Go to <B>HSPTV page</B></A>
</td>
<td>
<A HREF="http://www.onionsoft.net/hsp/">
<IMG SRC="onibtn.gif" BORDER=0 WIDTH=147 HEIGHT=50 ALT="ONION software" ALIGN=RIGHT></A>
</td>
</tr>
</table>
</div>
</div>
</BODY>
</HTML>

