------------------------------------------------------------------------------
HGIMG.DLL ver2.61   REFERENCE MANUAL   High Performance Graphic Image Plugin  
ＨＳＰ拡張DLLリファレンス             copyright 2001-2004 (c) onion software  
------------------------------------------------------------------------------

・はじめに

	このDLLは、Hot Soup Processor ver2.61以降とともに使用することで、様々な
	機能拡張を行なうことのできるプラグインモジュールです。
	この拡張DLLを使用することにより、新規命令が多数追加され、フルカラー、
	パレットモードでの2D・3Dグラフィック表示をサポートします。
	HGIMG.DLLは、Windows9x、NT、Me、2000、XP以降で動作します。


・インストール

	拡張プラグインのファイル、HGIMG.DLLは、HSPのインストールフォルダ
	(HSED2.EXEおよび、HSP2.EXEのあるディレクトリ)に置いてください。
	(実行に使われているHSP2.EXEと同じディレクトリに、HGIMG.DLLがない場合は
	エラーになります)
	また、スクリプトを作成する場合には、HSPをインストールしたフォルダ下に
	ある「common」ディレクトリに「hgimg.as」をコピーしておいてください。
	(スクリプトから#include命令で参照するために必要です)

	HGIMG.DLLを使用したスクリプトを作成する場合には、スクリプトの先頭に
	必ず「#include "hgimg.as"」という行を追加してください。
	以上で、HSPの機能が拡張され、このリファレンスで説明をしている命令を
	使用することができるようになります。
	まず最初に、試しに付属のサンプルスクリプトを実行してみてください。
	拡張された機能の簡単な使用例を見ることができるはずです。


・注意点

	HGIMG.DLLは、HSP2.EXE、HSP3.EXEと同時に使用されるプラグインファイルです。
	EXEファイルを作成した場合でも、HGIMG.DLLをEXEファイルと同じディレクトリ
	に置かないと動作しません。また、packfileにDLLを追加することはできません。


・著作権および連絡先

	著作権および、使用の規定についてはHot Soup Processor ver2.61と同様です。
	HSPによって作成したEXEファイルと同様にHGIMG.DLLを自由に配布してかまいません。
	また、付属のサンプルスクリプトは自由に改変、公開していただいて構いません。
	また、sampleディレクトリに含まれているmx形式モデルデータは、ライセンスフリーです。
	onion softwareは本プログラムによって生じた、いかなる損害についても
	保証いたしません。自己の責任の範囲で使用してください。


・HGIMG.DLLの概要

	HGIMG.DLLは、高度な2D、3Dグラフィックを使ったアプリケーションをHSPから
	作成するための拡張プラグインです。
	スプライトを使用した2Dゲームから、3Dモデルを使った本格的なソフトまで幅広く
	利用することができます。

	HGIMG.DLLで追加される主な機能は以下の通りです。

	・フルカラー、パレットモード、DirectXの有無などを切り替え可能なアーキテクチャ
	・2Dスプライト、3Dポリゴンなどを共通の命令で設定可能な描画エンジン
	・2Dスプライトの回転拡大縮小、α合成、透明色抜き処理、タイリング(BG表示)
	・3D座標上の2Dスプライトと3Dポリゴンを混在可能なワールド管理
	・3Dの階層構造を持ったポリゴンモデル表示、およびアニメーション管理
	・文字フォントテクスチャをもとにメッセージを合成表示
	・スプライトの表示、移動の管理および衝突判定機能
	・await命令より細かい単位でのウェイトと処理の負荷検出機能
	・CPU処理や描画の負荷が変わってもアニメーションの速度を一定に保つ
	  (フォールオフレンダリング)
	・32bit float精度によるジオメトリ演算
	・独自フォーマットによる3Dモデル、アニメーションデータの読み込み

	Ver2.55添付のバージョンと比べて以下の機能が追加されています。

	・独自のアニメーション形式(ma)によるモーション再生
	・リアルタイム光源計算の拡張(フラットシェーディング、グーローシェーディング)
	・DXF形式の3Dデータ読み込みをサポート
	・ポリゴン情報、および階層情報の参照と変更、mx形式でのセーブをサポート
	・画面上の2D位置から該当するポリゴンを検索するポリゴンスキャン機能
	・モデルの絶対的な位置情報を修正するmodelmovef命令の追加
	・DirectXのフルスクリーンモードサポート
	・フルカラー時のα合成サポート
	・ワイヤーフレーム表示モードのサポート
	・光源の設定

	以下の機能については、将来のバージョンでサポートされる予定です。

	・スペキュラー、環境マップなどの特殊マテリアル
	・ボーン情報によるワンスキンモデル表示およびアニメーションサポート
	・パーティクルモデルおよび特殊効果のサポート


・更新履歴

	2004/5/19 ( Ver2.61RC2 )

		描画用パケットサイズをシステムリクエストで設定可能に修正。

	2004/3/20 ( Ver2.61RC1 )

		カメラパラメーターの画角補正値、Z補正値を追加。
		モデルの拡大縮小を行なうmodelscalef命令を追加。
		objact命令のヘルプを更新。
		uvanim終了時に正常にオブジェクトが削除されない不具合を修正。
		mxload命令に上下反転読み込みスイッチを追加。
		fvdir命令の回転順番が正常に反映されていない不具合を修正。
		DirectX使用時(hgimgx.dll)にZバッファを使用するように修正。
		設定したオブジェクトの最大数に連動してMOC確保数を調整するように修正。

	2002/7/8 ( Ver2.0β2 )

		α合成などの特殊効果をオブジェクトに与えるパラメータとselefx命令を追加。
		フォント表示時のα値を設定するためのfalpha命令を追加。
		プラー効果を設定するためのclsblur命令を追加。
		光源の設定を行なうためのsellight,sellpos,sellang,sellcolor命令を追加。
		単色ポリゴンの作成設定を行なうsetcolor命令を追加。
		setreq命令で指定されたモデルの最大値、オブジェクトの最大値が反映
		されるように修正。
		角度指定用のobjset1r,objmov1r,objset2r,objmov2r,objset3r,objmov3r命令を追加。
		テクスチャ付きのグーローシェーディングの表示がおかしかった不具合を修正。
		ワイヤーフレーム表示プリミティブを追加。(modelshade命令で設定可)
		mxフォーマットの読み込み時のデータチェックを細かくした。
		mxフォーマットver2.0を公開。いくつかのパラメーターにはまだ未対応です。
		mxsave命令の出力フォーマットをver2.0に修正。
		addbg命令に透明色抜きモードの設定を追加。

	2002/3/15 ( Ver2.0β1 )

		DirectX使用時にテクスチャの解放に失敗することがある不具合を修正。
		DirectX使用時のスクリーンやテクスチャメモリをR8G8B8(32bpp)で初期化
		できなかった場合に、R5G5B5(16bpp)を選択するように修正。
		DirectXフルスクリーンモードをサポート。
		DirectX使用時に一部のポリゴン表裏判定が失敗する不具合を修正。
		テクスチャなし(カラード)ポリゴンが正常に描画されない不具合を修正。
		maload命令、objact命令を正式にサポート。
		modelmovef命令を追加。(モデル絶対座標の移動)
		dxfload命令を追加。(DXF形式のモデルデータ読み込みをサポート)
		modelshade命令を追加。(シェーディング機能の追加)
		objscan2、objscanf2命令を追加(2D座標からのポリゴンスキャン)
		ポリゴン情報の参照・修正のための命令追加
		(setmchild,setmsibling,getmsibling,getmchild,setmfv,getmfv,getmodel,putmodel
		getmuv,setmuv,setmpoly,getmpoly,nodemax)
		mxsave命令、mxtex命令を追加(内部データをmxファイルに書き出す)
		dupnode命令を追加
		gettree命令を追加
		hgreset命令を追加

	2001/9/9

		サンプルtest11、test12を追加。
		addplate命令でテクスチャが逆に貼られる不具合を修正。
		addmesh命令を追加。

	2001/6/25

		ver2.55β1に同梱。


・命令一覧

	hgini mode,yofs,ysize			DLLの初期化
	hgsrc							ソースバッファ指定
	hgdraw val, timer				描画の実行
	hgbye							DLLの開放
	getsync val,mode				時間待ち情報を取得
	sync val						時間待ちを行なう
	getdebug val					デバッグ情報取得
	hgsetreq type,val				システムリクエスト設定
	hggetreq val,type				システムリクエスト取得

	setborder sx,sy,sz				オブジェクト有効範囲設定
	clscolor sx,sy,cx,cy			背景色設定
	clstex id						背景テクスチャ設定
	setfont cx,cy,sw				オリジナルフォント定義
	fprt "mes",x,y					定義フォント文字列表示

	objset1 ofs,x					MOC情報を設定
	objadd1 ofs,x					MOC情報を加算
	objmov1 ofs,times,x				MOC移動情報を設定
	objsetf1 ofs,x					MOC情報を設定
	objaddf1 ofs,x					MOC情報を加算
	objmovf1 ofs,times,x			MOC移動情報を設定

	objset2 ofs,x,y					MOC情報を設定
	objadd2 ofs,x,y					MOC情報を加算
	objmov2 ofs,times,x,y			MOC移動情報を設定
	objsetf2 ofs,x,y				MOC情報を設定
	objaddf2 ofs,x,y				MOC情報を加算
	objmovf2 ofs,times,x,y			MOC移動情報を設定

	objset3 x,y,z					MOC情報を設定
	objadd3 x,y,z					MOC情報を加算
	objmov3 times,x,y,z				MOC移動情報を設定
	objsetf3 x,y,z					MOC情報を設定
	objaddf3 x,y,z					MOC情報を加算
	objmovf3 times,x,y,z			MOC移動情報を設定

	objcheck val					移動の終了を検知
	objmovmode mode					MOC移動モード設定
	objmovopt ofs,opt				MOC移動オプション設定

	selmoc id, mocofs				MOC情報を設定
	selpos id						移動座標をMOC情報に設定
	selang id						回転角度をMOC情報に設定
	selscale id						スケールをMOC情報に設定
	seldir id						移動量をMOC情報に設定
	objact ObjID, anim				指定アニメーションを開始

	cammode mode					カメラモードの設定
	selcam ofs						カメラをMOC情報に設定
	selcpos							カメラ座標をMOC情報に設定
	selcang							カメラ角度をMOC情報に設定
	selcint							カメラ注視点をMOC情報に設定

	objgetfv fv						MOC情報を取得
	objsetfv fv						MOC情報を設定
	objaddfv fv						MOC情報を加算
	objmovfv fv,times				MOC移動情報を設定
	objgetv v						MOC情報を整数値で取得
	objsetv v						MOC情報を整数値で設定
	objgetstr sval					MOC情報を文字列で取得

	fvget							(未使用)
	fvset fv,x,y,z					ベクトル設定
	fvseti fv,x,y,z					整数値からベクトル設定
	fvadd fv,x,y,z					ベクトル加算
	fvsub fv,x,y,z					ベクトル減算
	fvmul fv,x,y,z					ベクトル乗算
	fvdiv fv,x,y,z					ベクトル除算
	fvdir fv,x,y,z					ベクトル回転
	fvmin fv,x,y,z					ベクトル最大値
	fvmax fv,x,y,z					ベクトル最小値
	fvouter fv,x,y,z				ベクトル外積
	fvinner fv,x,y,z				ベクトル内積
	fvface fv,x,y,z					座標から角度を得る
	fvunit fv						ベクトル正規化
	fsin fval,rot					サインを求める
	fcos fval,rot					コサインを求める
	fsqr fval,prm					平方根を求める
	fadd fval,prm					小数値加算
	fsub fval,prm					小数値減算
	fmul fval,prm					小数値乗算
	fdiv fval,prm					小数値除算
	fcmp val,prm1,prm2				小数値比較
	froti fval,prm					整数値角度を小数値に変換

	fv2str fv						ベクトルを文字列に変換
	str2fv fv,"x,y,z"				文字列をベクトルに変換
	str2f fval,"val"				文字列を小数値に変換
	f2str val,fval					小数値を文字列に変換
	f2i v,x,y,z						小数値を整数値に変換

	setuv tx0,ty0,tx1,ty1			登録テクスチャUV座標を指定
	setsizef sx,sy					登録モデルの幅、高さを指定
	setbg sx,sy,cx,cy				BGマップ情報設定
	getbg val,modelID				BGマップを取得
	setmap modelID,x,y				BGマップスクロール指定
	addbox val						箱(BOX)モデルを作成
	addplate val, mode				板(PLATE)モデルを作成
	addspr val, mode				2Dスプライトモデルを作成
	addbg val, winx, winy,sw		2DBGマップモデルを作成
	mxload "filename",sw				モデルファイル読み込み
	regobj val,ModelID, mode		オブジェクトの登録
	delobj ObjID					オブジェクトの削除
	setobjm ObjID, ModelID			オブジェクトのモデル設定
	setobjmode id,mode,sw			オブジェクトのモード設定
	setcoli id,mygroup,enegroup		オブジェクトのコリジョン設定
	getcoli val,id,distance			オブジェクトのコリジョン判定
	findobj exmode,group			オブジェクト検索
	nextobj val						次のオブジェクト検索

	uvanim id, wait, times, sw		モデルのUVアニメ設定
	setmode ModelID, mode			モデルのモード設定
	settimer ModelID, timer			モデルのタイマー設定
	setmtex id, nodeid, tex, shade	モデルのテクスチャを設定
	getmtex val, modelid, nodeid	モデルのテクスチャを取得
	getnode val, modelID, nodeID	モデルのノード情報を取得

	evmodel eventID, modelID		イベントモデルID設定

	copybuf mode					指定バッファに画面コピー

	mxsend val						MX形式ファイルをパース
	mxconv val						MX形式ファイルを変換
	mxaconv val						MA形式ファイルを変換
	mxgetpoly val					ポリゴン数を取得
	mxgetname val,id				テクスチャ名を取得
	settex x,y,sw					テクスチャを登録
	gettex val						テクスチャIDを取得


	新規追加命令

	objset1r ofs,x					MOC情報を設定
	objmov1r ofs,times,x			MOC移動情報を設定
	objset2r ofs,x,y				MOC情報を設定
	objmov2r ofs,times,x,y			MOC移動情報を設定
	objset3r x,y,z					MOC情報を設定
	objmov3r times,x,y,z			MOC移動情報を設定

	clsblur val						ブラー設定
	setcolor r,g,b					単色ポリゴン作成設定
	falpha val						フォント文字α値を設定

	selefx id						オブジェクト特殊効果をMOC情報に設定
	sellight id,ofs					光源をMOC情報に設定
	sellpos	id						光源座標をMOC情報に設定
	sellang	id						光源角度をMOC情報に設定
	sellcolor id					光源色をMOC情報に設定

	maload "file"					モデルアニメーションを読み込み

	modelmovef id,x,y,z				モデルの絶対位置を移動
	modelscalef id,x,y,z				モデルの拡大縮小
	modelshade id,mode				モデルシェーディングモードの設定

	dxfload "file"					DXF形式ファイルを読み込み
	dxfconv val						DXF形式ファイルをパース
	dxfgetpoly val					ポリゴン数を取得

	objscanf2 val,x,y				2D座標からポリゴン検索
	objscan2 val,x,y				2D座標からポリゴン検索

	setmchild model_id,sub_id,id	階層の子を設定
	setmsibling model_id,sub_id,id	階層の兄弟を設定
	getmchild val,id,sub_id			指定した階層の子を取得
	getmsibling val,id,sub_id		指定した階層の兄弟を取得
	setmfv fv,model_id,sub_id,type	階層パラメータを設定
	getmfv fv,model_id,sub_id,type	階層パラメータを取得
	getmodel val,model_id,sub_id	モデル情報を読み出し
	putmodel val,model_id,sub_id	モデル情報を書き出し
	dupnode val,ID,subID,nodeID		ノード情報へのクローンを作成
	mxsave "file",id				指定モデルをMX形式で出力
	mxtex val						MX形式出力時のテクスチャリスト登録
	gettree val,id					指定モデル階層構造をテキストで取得
	hgreset							シーン情報の初期化
	setmuv val,model_id,node_id		UV情報の設定
	getmuv val,model_id,node_id		UV情報の取得
	nodemax model_id,sub_id			ノード情報の数を取得
	setmpoly val,id,node_id,mode	ポリゴン頂点情報の設定
	setmpoly val,id,node_id,mode	ポリゴン頂点情報の取得


・動作の概要

	HGIMG.DLLは、すべてのマシンで同等の表示、スピードを再現することを目指して
	開発されています。3Dアクセラレーターを搭載しない機種(ノート型やオンボード
	ビデオチップ搭載機種など)、であっても著しくパフォーマンスが落ちることなく
	動作させることができます。また、初期化を手軽に行なえるとともにDirectX
	バージョンの不一致やドライバの相性などによる不具合が起こらず、すべての
	Windows動作マシンで正常な表示が期待できます。(DirectX使用モードの場合は
	除く)

	大量の画像や、3Dデータを使用したソフトで問題となるのは描画にかかる負荷、
	つまり絵を描くのに時間がかかってしまう点です。
	HGIMG.DLLでは、描画をする場合にCPUの処理能力が期待した時間内に終わらない
	場合には、間のコマをキャンセルすることで画面内で動く速度については一定の
	速さを保つことができます(フォールオフレンダリング)。
	たとえば、高速なマシンでは1秒に60コマの描画ができるとして、それよりも
	遅いマシンでは、画面の動く速さ自体は同じですが1秒に30コマしか描画されない
	(間の１コマがスキップされている)というようなことが起こります。

	HGIMG.DLLでは、「モデル」と「オブジェクト」という単位で描画の管理を行なって
	います。HSPの命令の多くは、準備の必要もなく目的の処理を行なっていましたが、
	HGIMG.DLLでは、最初の準備段階として使うものを「登録」しておき、後でまとめて
	全部を描画するスタイルを取っています。これは直感的ではない反面、処理の効率化
	と高速化を図ることができます。HGIMG.DLLには、100種類以上の命令があり最初は
	その複雑さに戸惑うかもしれませんが、最低限使うものはわずかですので、少しづつ
	使って覚えていってください。

	何らかの絵を出す場合には、最初に「モデル」を登録する必要があります。
	「モデル」は、

		・2Dスプライト
		・3Dスプライト(板)
		・立方体
		・3Dモデル

	のような種類があり、それぞれの種類に応じて色々な設定項目があります。
	たとえば、2Dの絵を画面に表示したい場合は、種類が「2Dスプライト」の「モデル」
	を最初に登録しなければなりません。
	「2Dスプライト」は、表示に使う絵(テクスチャ)やアニメーションの設定などが
	あり、必要な項目を設定すればOKです。

	「モデル」を登録しただけでは画面には何も表示されません。
	「モデル」は、画面に表示するための材料となります。画面に表示される可能性が
	あるものをあらかじめ材料としてストックしておくものと考えて下さい。

	「モデル」に続いて、「オブジェクト」を登録します。
	「オブジェクト」は「どの場所にどのモデルを出すか」という情報を持った器の
	ようなものです。「オブジェクト」が指す「モデル」を画面に表示します。
	「オブジェクト」は単なる器なので、同じ物体を２つ画面に出す場合には、
	「モデル」を1つ登録して、そのモデルを持った「オブジェクト」を２つ登録すれば
	いいことになります。「モデル」は、その形や色自体の情報を持っておき、
	「オブジェクト」は、「モデル」を画面上に出す場所や動きの設定などを持っている
	と考えておいてください。

	これらの概念をもとに、2D、3D画像をコントロールするための命令が多数用意されて
	います。
	HGIMG.DLLま内部では、すべて32bit浮動小数によりパラメータを管理、演算されて
	います。また、命令の多くはHSP ver2.55以降で拡張されている浮動小数記述による
	パラメータを必要としています。
	たとえば、

			objaddf3 1.0f, 1.5f, 2.0f

	のように小数値が必要な命令では、末尾に「f」のついた小数値で指定してください。


・初期化と描画の方法

	HGIMG.DLLでは、初期化を以下の手順に従って行なって下さい。

	;------------------------------------------------------------------
	screen 0,320,240,0
	hgini						; hgimgの初期化
	;------------------------------------------------------------------

	hgini命令は、プラグインの全初期化を行なう命令です。
	hgini命令が実行された時点でアクティブなウインドゥのサイズと、
	色モードをもとに初期化を行ないます。
	上の例では、320x240ドット、フルカラーモードで描画を行なうことに
	なります。

	初期化を連続して行なうことはできません。
	再初期化する場合は、hgbye命令ですべての終了処理を行なった後に実行
	するようにしてください。

	また、プログラムの終了時にもhgbyeですべての終了処理を行なうことを
	推奨します。hgbye命令自体は、自動クリーンアップ命令でHSPの終了時に
	自動的に呼び出されます。

	初期化が終わったら、いつでも登録されているオブジェクトを表示可能な
	状態になります。
	HGIMG.DLLでは、描画を以下のように行ないます。

	;------------------------------------------------------------------
	gsel 0
*main
	;	描画メイン
	;
	hgdraw				; 描画処理
	hgsync 10			; 時間待ち
	goto *main
	;------------------------------------------------------------------

	hgdraw命令で、HGIMG.DLLが受け持つすべての描画を行ないます。
	この時、描画先のウインドゥをgsel命令などでアクティブにしておくのを
	忘れないでください。
	その後、hgsync命令で時間待ち(ウェイト)をします。「hgsync 10」の場合は、
	10msだけ待ち時間を入れます。
	この２つの命令を必ず入れれば全描画と待ち時間の処理は完結します。
	HSPのwaitやawait命令を入れる必要はありません。


・モデル設定命令

	モデルの登録をするためには、種類に応じて命令が異なります。
	主な登録の方法は以下の通りです。

	・2Dスプライト

		setuv tx0,ty0,tx1,ty1		;UV座標の設定
		addspr val, mode			;2Dスプライトモデルを作成

		テクスチャ座標の左上(tx0,ty0)と右下(tx1,ty1)の大きさに
		応じたサイズの2Dスプライトモデルを作成します。
		回転、拡大縮小、合成などを行なうことができます。
		変数valにモデルIDが代入されます。
		これに続いてtexload命令で読み込まれたテクスチャ(画像)を使用します。
		addspr命令のmode値が0の場合は透明色抜き処理を行ないません。
		mode値が1の場合は指定された色を透明色として扱って描画します。

	・2DBGマップ

		setbg sx,sy,cx,cy					;マップサイズ、チップサイズ設定
		addbg val, winsizex, winsizey,sw	;2DBGマップモデルを作成

		マップのサイズが(sx,sy)、チップサイズを(cx,cy)とするBGマップ表示
		モデルを作成します。
		変数valにモデルIDが代入されます。
		これに続いてtexload命令で読み込まれたテクスチャ(画像)を使用します。

	・単色3Dスプライト(板)

		setsizef sx,sy				;板の大きさ設定
		setcolor 0,255,0			;色の設定
		addplate val, mode			;板(PLATE)モデルを作成

		縦横サイズが(sx,sy)の四角ポリゴン(板)のモデルを作成します。
		色は、緑(R=0,G=255,B=0)となります。
		変数valにモデルIDが代入されます。
		mode値が2の場合は光源計算を行ないます。

	・3Dスプライト(板)

		setsizef sx,sy				;板の大きさ設定
		setuv tx0,ty0,tx1,ty1		;UV座標の設定
		addplate val, mode			;板(PLATE)モデルを作成

		テクスチャ座標が左上(tx0,ty0)と右下(tx1,ty1)のもので、
		縦横サイズが(sx,sy)の四角ポリゴン(板)のモデルを作成します。
		変数valにモデルIDが代入されます。
		これに続いてtexload命令で読み込まれたテクスチャ(画像)を使用します。
		addplate命令のmode値が0の場合は透明色抜き処理を行ないません。
		mode値が1の場合は指定された色を透明色として扱って描画します。

	・単色の箱(立方体)

		setsizef sx,sy				;箱の大きさ設定
		setcolor 255,0,0			;色の設定
		addbox val,2				;箱(BOX)モデルを作成

		サイズが(sx,sy)の箱(立方体)モデルを作成します。
		色は赤(R=255,G=0,B=0)で、光源計算を行ないます。
		変数valにモデルIDが代入されます。

	・テクスチャ使用の箱(立方体)

		setsizef sx,sy				;箱の大きさ設定
		setuv tx0,ty0,tx1,ty1		;UV座標の設定
		addbox val					;箱(BOX)モデルを作成

		サイズが(sx,sy)の箱(立方体)モデルを作成します。
		テクスチャ座標は左上(tx0,ty0)と右下(tx1,ty1)が１つの面となり、
		さらに(tx0,(ty1-ty0)+1)と、(tx0,((ty1-ty0)+1)*2)からの3つの面を
		テクスチャとして持つ箱モデルが作られます。
		変数valにモデルIDが代入されます。
		これに続いてtexload命令で読み込まれたテクスチャ(画像)を使用します。

	・3Dモデル

		mxload "filename",sw			;モデルファイル読み込み

		"filename"で指定されたポリゴンモデルファイル(拡張子mx)を読み込み
		モデルとして登録します。また、テクスチャも同時に読み込まれます。
		システム変数statにモデルIDが代入されます。
		swに1を指定した場合は、mxファイルに記録された内容と上下反転した
		モデルとして読み込みます。これは、一部の3Dツールやモデルコンバーター
		の座標系との互換を取るためのオプションです。
		swが0か省略されている場合には、通常の読み込みとなります。

	モデルを対象にした命令はこれ以外に以下のようなものがあります。
	詳しくはリファレンスを参照してください。

		uvanim id, wait, times, sw		モデルのUVアニメ設定
		setmode ModelID, mode			モデルのモード設定
		settimer ModelID, timer			モデルのタイマー設定
		setmtex id, nodeid, tex, shade	モデルのテクスチャを設定
		getmtex val, modelid, nodeid	モデルのテクスチャを取得
		getnode val, modelID, nodeID	モデルのノード情報を取得


・オブジェクト設定命令

	オブジェクトを登録する場合は、

		regobj 変数名, モデルID, モード

	の命令を使用します。
	regobjでは、すでに登録されているモデルIDと、モードを指定する必要が
	あります。
	モードは以下の中から選択します。

		ラベル             |        内容
		--------------------------------------------------------------
		OBJ_HIDE             非表示(画面から消す)
		OBJ_TREE             木属性(Y軸のみ正面を向く)
		OBJ_XFRONT           正面属性(常に画面に正面を向く)
		OBJ_UVANIM           UVアニメーションを行なう
		OBJ_UVANIM_1SHOT     UVアニメーション表示後に消滅する
		OBJ_MOVE             XYZ移動量を有効にする
		OBJ_FLIP             ボーダー領域で反転する
		OBJ_BORDER           ボーダー領域を有効にする
		OBJ_2D               2D表示オブジェクトとして扱う
		OBJ_TIMER            消滅タイマーを有効にする
		OBJ_WIPEBOM          ボーダー領域で爆発オブジェクトに変わる
		OBJ_NOSORT           Zソートを無効にする
		OBJ_GRAVITY          重力制御を有効にする
		OBJ_SKY              常に一番奥に描かれる
		OBJ_GROUND           地面オブジェクトとして描かれる

	複数の項目を同時に選択する場合は、「OBJ_SKY|OBJ_MOVE」のように
	「|」で区切って指定してください。何も指定しない場合は、0にするか
	省略して構いません。
	オブジェクトのモードは、あらかじめデフォルトのモードがモデルの種類に応じて
	設定されているので、通常は特に設定する必要はありません。
	また、setmode命令でモデルにモードを指定した場合は、そのモードが
	オブジェクトにも継承されます。

	正常にオブジェクトが登録されると変数にオブジェクトIDが
	返されます。オブジェクトIDは、その後にオブジェクトのパラメータや
	設定を変更する場合に必要になる番号です。

	オブジェクトの設定を後から変更する命令は以下の通りです。

		setobjm ObjID, ModelID			オブジェクトのモデル設定
		setobjmode id,mode,sw			オブジェクトのモード設定
		setcoli id,mygroup,enegroup		オブジェクトのコリジョン設定

	オブジェクトの設定は、MOC設定命令でも行なうことができます。
	詳しくは、MOC設定命令についてを参照してください。
	以下は2Dスプライトのモデルを登録して、さらにそれをオブジェクトとして
	登録するスクリプトの例です。

			例:
				;	スプライトの登録
				;
				setuv 0,0,79,79				; UV座標指定
				addspr pchr					; モデルの登録
				texload "rock2.bmp"			; テクスチャの登録
				regobj mychr,pchr,OBJ_2D	; オブジェクト登録


・MOC設定命令について

	HGIMG.DLLでは、「オブジェクト」の管理をさらに高度に行なうために、
	MOC(Motion Object Controller)という仕組みが用意されています。
	これは、「オブジェクト」の移動やサイズの変更、回転などの情報、さらに
	アニメーションさせるための情報をすべて扱うシステムです。
	MOCは、「オブジェクト」の表示位置、回転角度、サイズ、移動量などの
	情報をすべて浮動小数で記憶しています。これらすべてのパラメータを、
	任意の値に変更、指定フレーム後に任意の値になるように値を増減させる
	ことができるようになっています。

	HGIMG.DLLの「オブジェクト」は、以下のようなパラメータを持っています。

		「HGIMG.DLLオブジェクト パラメータ」

		グループ    offset0      offset1     offset2      offset3
		--------------------------------------------------------------
		  A         [X座標]      [Y座標]     [Z座標]      [未使用]
		  B         [X回転角]    [Y回転角]   [Z回転角]    [未使用]
		  C         [X倍率]      [Y倍率]     [Z倍率]      [未使用]
		  D         [X移動量]    [Y移動量]   [Z移動量]    [未使用]
		  E         [α合成値]   [EFX1]      [EFX2]       [EFX3]

		また、特別な存在である「カメラ」は以下のようなパラメータを
		持っています。

		「HGIMG.DLLカメラオブジェクト パラメータ」

		グループ    offset0      offset1     offset2      offset3
		--------------------------------------------------------------
		  A         [X座標]      [Y座標]     [Z座標]      [未使用]
		  B         [X回転角]    [Y回転角]   [Z回転角]    [未使用]
		  C         [X注視座標]  [Y注視座標] [Z注視座標]  [未使用]
		  D         [画角補正値] [Z補正値]   [未使用]     [未使用]

		そして、光源計算を行なう場合に使用される特殊な存在として
		「ライト(光源)」は以下のようなパラメータを持っています。

		「HGIMG.DLLライトオブジェクト パラメータ」

		グループ    offset0      offset1     offset2      offset3
		--------------------------------------------------------------
		  A         [X座標]      [Y座標]     [Z座標]      [未使用]
		  B         [X回転角]    [Y回転角]   [Z回転角]    [未使用]
		  C         [カラーR]    [カラーG]   [カラーB]    [未使用]
		  D         [ambientR]   [ambientG]  [ambientB]   [未使用]
		  E         [range]      [falloff]   [theta]      [phi]

	グループA〜Eまでにそれぞれoffset0〜3までの合計20個のパラメータが存在
	しています。それらのパラメータを更新することで、画面に表示されている
	オブジェクトにも反映されます。3D表示されているオブジェクトについては
	Z座標などを含めた３次元情報が使われ、2D表示されているオブジェクトに
	ついてはZ回転などいくつかの項目は無視されます。
	どのグループを書き換え対象にするかを指定するものは、

		selpos id		移動座標(グループA)をMOC情報に設定
		selang id		回転角度(グループB)をMOC情報に設定
		selscale id		スケール(グループC)をMOC情報に設定
		seldir id		移動量(グループD)をMOC情報に設定
		selefx id		特殊効果(グループE)をMOC情報に設定

	があります。idは、オブジェクトID(番号)になります。
	これらのパラメータを更新するためにMOC設定命令群が用意されています。
	設定するには、まず「どのオブジェクトのどのグループを書き換え対象に
	するか」を指定します。次に、offset0〜3のどの部分を変更するかを指定
	する２段階が必要になります。
	オブジェクトの各グループは、以下のような意味を持っています。

		 グループ A: (初期値:0,0,0)
			オブジェクトのX,Y,Z座標を指定します。
		 グループ B: (初期値:0,0,0)
			オブジェクトの向いているX,Y,Z角度を指定します。
		 グループ C: (初期値:1,1,1)
			オブジェクトの倍率(X,Y,Z軸)を指定します。
		 グループ D: (初期値:0,0,0)
			オブジェクトのX,Y,Z方向に対する移動量を指定します。
			setobjmode命令によってOBJ_MOVEフラグが設定されている
			時にのみ参照されます。
		 グループ E: (初期値:256,0,0,0)
			オブジェクトの特殊効果を設定します。
			4つの値を格納していますが、
			オフセット0 : [α合成値]
			オフセット1 : [EFX1]
			オフセット2 : [EFX2]
			オフセット3 : [EFX3]
			となっています。
			(*現バージョンではグループEはα合成値のみサポートされています)

			α合成値は、背景とオブジェクトを合成する度合いを指定します。

			α合成値 = 0〜255    : 背景とα合成(blend)を行なう
			α合成値 = 256〜511  : 合成を行なわない(通常時)
			α合成値 = 512〜767  : 背景と色加算(modulate)を行なう
			α合成値 = 768〜1023 : 背景と色減算(substract)を行なう

			合成を行なう場合には、α合成値の値が大きいほど、高い%で合成が
			行なわれます。α合成は、シェーディング、2D、3Dの区別なく処理
			されますが、DirectX、フルカラーモード時のみサポートされます。

	カメラオブジェクトのグループを指定する場合には、

		selcpos			カメラ座標(グループA)をMOC情報に設定
		selcang			カメラ角度(グループB)をMOC情報に設定
		selcint			カメラ注視点(グループC)をMOC情報に設定

	を使用します。
	カメラの各グループは、以下のような意味を持っています。

		 グループ A:
			カメラのX,Y,Z座標を指定します。
		 グループ B:
			カメラの向いているX,Y,Z角度を指定します。
			ただし、cammode命令で注視点モード設定中は無視されます。
		 グループ C:
			カメラが見る座標(注視点)のX,Y,Zを指定します。
			ただし、cammode命令で注視点モード設定中のみ参照されます。
		 グループ D:
			[画角補正値]と、[Z補正値]を設定可能です。
			パースのかかりぐあいを調整する値と、全体のスケールを調整する
			ことができます。
			(この値は、hgimg.dllとhgimgx.dllとで計算上の誤差が生じます)

		(*現バージョンではグループA〜Dのみサポートされています)

	ライト(光源)オブジェクトのグループを指定する場合には、

		sellpos	id			光源座標(グループA)をMOC情報に設定
		sellang	id			光源角度(グループB)をMOC情報に設定
		sellcolor id		光源色(グループC)をMOC情報に設定

	を使用します。
	ライト(光源)は、同時に４つまで設定可能です。
	そのために光源IDを0〜3の範囲で指定する必要があります。
	ライト(光源)の各グループは、以下のような意味を持っています。

		 グループ A: (初期値:0,0,0)
			光源の座標を指定します。点光源(ポイントライト)および、
			スポットライト動作時に反映されます。
		 グループ B: (初期値:-2.5,-0.25,0)
			光源の向き(角度)を指定します。
		 グループ C: (初期値:255,255,255)
			光源の色をRGBで指定します。
			それぞれ0〜255の値が設定可能です。
		 グループ D: (初期値:32,32,32)
			光源の環境色(アンビエントカラー)を指定します。
			それぞれ0〜255の値が設定可能です。
		 グループ E: (初期値:0,0,0)
			光源の高度な設定を行ないます。
			点光源(ポイントライト)および、スポットライト動作時に
			反映されます。

	(*現バージョンでは光源ID0のみ反映され、平行光源のみ使用できます)

	また、直接グループを値で設定するための命令として、

		selmoc id, group	オブジェクトのMOCグループ指定
		selcam group		カメラのMOCグループ指定
		sellight id,ofs		光源をMOC情報に設定

	があります。groupは、012…の順番にABC…が割り当てられます。
	グループが指定されたら、次は実際の値を設定します。これには、多様な
	設定方法がありますが、最も単純な方法は、

		objsetf1 ofs,x					MOC情報を設定

	の命令で、ofsにオフセット番号、xに設定する値を指定することです。
	これで目的のパラメータを任意の値に設定することができます。
	objsetf1命令は、xの値を浮動小数で指定する必要があります。
	たとえば、

		objsetf1 1, 1.5f

	は、オフセット1のパラメータを1.5という値に設定することになります。
	これを小数値ではなく、通常の整数値を使うための命令もあります。

		objset1 1, 2

	は、オフセット1のパラメータに2という値を設定することになります。
	このようにパラメータの設定には、小数値を使うものと、整数値を使うもの
	２通りが用意されています。
	さらに、2つのパラメータを同時に設定するための命令、

		objsetf2 ofs,x,y				MOC情報を設定
		objset2 ofs,x,y					MOC情報を設定

	も用意されています。これは、2DスプライトのX,Y座標など2つのパラメータを
	セットで指定する場合に都合のよい命令です。この場合は、指定したオフセット
	とその次のオフセットが設定の対象になります。
	そして3つのパラメータを同時に設定するための命令、

		objsetf3 x,y,z					MOC情報を設定
		objset3 x,y,z					MOC情報を設定

	も同様に用意されています。ここでは、必ずオフセット0,1,2が設定の対象に
	なります。3D座標などのX,Y,Z値を同時に指定する場合に都合のよい命令です。
	いずれの場合も、objsetに続く「f」があれば小数値指定、それに続く数字が
	パラメータの設定数になっていることに注意してください。
	これらに加えて、

		objadd1 ofs,x					MOC情報を加算
		objaddf1 ofs,x					MOC情報を加算
		objadd2 ofs,x,y					MOC情報を加算
		objaddf2 ofs,x,y				MOC情報を加算
		objadd3 x,y,z					MOC情報を加算
		objaddf3 x,y,z					MOC情報を加算

	は、対象となるパラメータに記憶されていた値に対して、指定値を加算する
	命令も用意されています。加算値にマイナスの値を使うことで、減算をする
	ことも可能です。
	パラメータを時間とともに変化させることもできます。

		objmov1 ofs,times,x				MOC移動情報を設定
		objmovf1 ofs,times,x			MOC移動情報を設定
		objmov2 ofs,times,x,y			MOC移動情報を設定
		objmovf2 ofs,times,x,y			MOC移動情報を設定
		objmov3 times,x,y,z				MOC移動情報を設定
		objmovf3 times,x,y,z			MOC移動情報を設定

	上の命令は、timesで指定したフレーム数後に指定したパラメータの値に
	なるように設定します。指定したフレーム数の間はゆっくりと値が変化して
	いきます。これにより、移動アニメーションやゆるやかな回転、拡大の
	アニメーションを簡単に指定することができます。
	MOCでは、この時の値の変化具合を設定することができます。
	MOCのグループを選択した状態で、

		objmovmode 補間モード

	で、そのグループに対して補間モードを設定することができます。
	ここで補間モードに使用できるのは、以下の通りです。

		OBJMOV_STATIC		値変化なし
		OBJMOV_LINEAR		直線補間
		OBJMOV_SPLINE		スプライン補間

	たとえば、

		objmovmode OBJMOV_SPLINE	; スプライン補間モードを選択

	は、スプライン補間モードに設定したことになります。
	スプライン補間にした場合は、objmov系の命令で変化させる値を２個まで
	同時にストックできるようになり、それぞれの点をなめらかに通るような
	形で値の増減が行なわれます。
	デフォルトでは、すべてのグループの補間モードは直線補間になっています。

	MOC情報を設定するものの中で、パラメーターとして角度を指定する場所で
	使用する専用の命令が用意されています。
	objset1rやobjmov1rなど、最後に「r」がついています。
	これは、通常ラジアン単位の角度を指定するべきパラメーターを、整数値で
	指定できるようにしたものです。

		objset1r ofs,x					MOC情報を設定
		objmov1r ofs,times,x			MOC移動情報を設定
		objset2r ofs,x,y				MOC情報を設定
		objmov2r ofs,times,x,y			MOC移動情報を設定
		objset3r x,y,z					MOC情報を設定
		objmov3r times,x,y,z			MOC移動情報を設定

	これらの命令は、回転情報を0〜255までを１周とする単位で扱うことができます。

	最後にパラメータを変数に取り出したり、逆に変数に後で説明するFV形式
	で格納されている値をパラメータに設定するための命令が用意されています。

		objgetfv fv						MOC情報を取得
		objsetfv fv						MOC情報を設定
		objaddfv fv						MOC情報を加算
		objmovfv fv,times				MOC移動情報を設定
		objgetv v						MOC情報を整数値で取得
		objsetv v						MOC情報を整数値で設定

	これらの命令を使うことで、多くのパラメータを効率よく管理、変更する
	ことができるようになっています。
	MOC設定命令をマスターすれば、すべてのオブジェクトを思いのままに
	コントロールすることができるでしょう。

	オブジェクト使用の際には以下の点に注意しておいてください。

	・2Dオブジェクトの座標は画面の中心が(0,0)となります
	・オブジェクトの回転角度の単位はラジアンです
	・回転順序は常にZ->Y->Xとなります
	・3Dオブジェクトは画面の解像度に従ってスケールが補正されます


・浮動小数サポート命令

	浮動小数サポート命令は、小数値、ベクトル値などの情報を扱うための
	命令群です。ベクトルを変数に格納する方法としてFV値という表現が出て
	きますが、これは「変数名=1.0f」のように1つの値を代入するのではなく
	「変数名.0=X:変数名.1=Y:変数名.2=Z」のように配列変数として3つの要素
	(X,Y,Z)を格納しておく形式です。通常HSPでは、すべての変数が0から15までの
	要素を持った配列変数として使用できるので、3つの値を持った変数として
	扱っても問題ありません。
	FV値を使用することで、３次元座標や角度(ベクトル)などの情報を比較的
	整理して扱うことができます。FV値を演算する命令では、同時に3つの要素に
	対して計算されるため、１つの要素ごとに計算するよりもシンプルで高速に
	処理を行なうことができます。

	fvget							(未使用)

		現在使用されていません

	fvseti fv,x,y,z					整数値からベクトル設定

		fv      = FV値が代入される変数名
		(x,y,z) = int値(整数値)

		(x,y,z)で指定された整数値をベクトルとしてFV値に代入する。

	fvset fv,x,y,z					ベクトル設定
	fvadd fv,x,y,z					ベクトル加算
	fvsub fv,x,y,z					ベクトル減算
	fvmul fv,x,y,z					ベクトル乗算
	fvdiv fv,x,y,z					ベクトル除算

		fv      = FV値が代入される変数名
		(x,y,z) = 計算値(float値)

		fvで指定された変数に格納されているFV値と、指定された
		小数値(X,Y,Z)の演算を並列で行ないます。

	fvdir fv,x,y,z					ベクトル回転

		fv      = FV値が代入される変数名
		(x,y,z) = 回転角度(float値)

		fvで指定された変数に格納されているベクトル(FV値)を、
		小数値(X,Y,Z)で指定されたX,Y,Z角度に回転させます。

	fvmin fv,x,y,z					ベクトル最大値

		fv      = FV値が代入される変数名
		(x,y,z) = 比較値(float値)

		fvで指定された変数に格納されているFV値と、
		小数値(X,Y,Z)を比較して、値の大きいものを代入します。
		FV値の各要素を最小値までに切り詰める場合に使用します。

	fvmax fv,x,y,z					ベクトル最小値

		fv      = FV値が代入される変数名
		(x,y,z) = 比較値(float値)

		fvで指定された変数に格納されているFV値と、
		小数値(X,Y,Z)を比較して、値の小さいものを代入します。
		FV値の各要素を最大値までに切り詰める場合に使用します。

	fvouter fv,x,y,z				ベクトル外積

		fv      = FV値が代入される変数名
		(x,y,z) = 演算するベクトル値(float値)

		fvで指定された変数に格納されているFV値と、
		小数値(X,Y,Z)で指定するベクトルの外積を求めて代入します。

	fvinner fv,x,y,z				ベクトル内積

		fv      = FV値が代入される変数名
		(x,y,z) = 演算するベクトル値(float値)

		fvで指定された変数に格納されているFV値と、
		小数値(X,Y,Z)で指定するベクトルの内積を求めてfv.0に代入します。

	fvface fv,x,y,z					座標から角度を得る

		fv      = FV値が代入される変数名
		(x,y,z) = X,Y,Z座標値(float値)

		fvで指定された変数に格納されているベクトル(FV値)を基点とする
		X,Y,Z座標から、指定されたX,Y,Z座標を直線で見るための回転角度を求めて
		代入します。

	fvunit fv						ベクトル正規化

		fv      = FV値が代入される変数名

		fvで指定された変数に格納されているベクトル(FV値)を正規化します。

	fsin fval,rot					サインを求める

		fval    = float値が代入される変数名
		rot     = 回転角度(float)

		rotで指定された角度のサイン値をfvalで指定した変数に代入します。
		角度の単位はラジアンになります。

	fcos fval,rot					コサインを求める

		fval    = float値が代入される変数名
		rot     = 回転角度(float)

		rotで指定された角度のコサイン値をfvalで指定した変数に代入します。
		角度の単位はラジアンになります。

	fsqr fval,prm					平方根を求める

		fval    = float値が代入される変数名
		prm     = 演算に使われる値(float)

		prmで指定された値の平方根をfvalで指定した変数に代入します。

	fadd fval,prm					小数値加算
	fsub fval,prm					小数値減算
	fmul fval,prm					小数値乗算
	fdiv fval,prm					小数値除算

		fval    = float値が代入される変数名
		prm     = 演算に使われる値(float)

		fvalで指定した変数に代入されている小数値に対して、
		prmで指定された値を加算/減算/乗算/除算します。

	fcmp val,prm1,prm2				小数値比較

		val     = 結果が代入される変数
		prm1    = 比較値1(float)
		prm2    = 比較値2(float)

		比較値1と比較値2を比較した結果をvalで指定した変数に代入します。
		代入される値は通常の整数になります。

		    条件               |  結果
		---------------------------------------
		    比較値1 = 比較値2  |    0
		    比較値1 > 比較値2  |    1
		    比較値1 < 比較値2  |   -1

	froti fval,prm					整数値角度を小数値に変換

		fval    = float値が代入される変数名
		prm     = 0〜1023の角度値(int)

		prmで指定された整数値(0〜1023)を角度を示すものとして、
		fvalに-π〜+πのラジアン角度値に変換して代入します。

	fv2str fv						ベクトルを文字列に変換

		fvで指定された変数に格納されているベクトル(FV値)を文字列に
		変換してシステム変数refstrに結果を返します。

	str2fv fv,"x,y,z"				文字列をベクトルに変換

		"x,y,z"で指定された文字列情報を「,」で区切られたX,Y,Z小数値として
		読み出し、fvで指定された変数に格納します。

	str2f fval,"val"				文字列を小数値に変換

		"val"で指定された文字列情報を小数値として読み出し、
		fvalで指定された変数に格納します。

	f2str val,fval					小数値を文字列に変換

		fvalで指定された小数値を文字列に変換して、valで指定された文字列型の
		変数に結果を返します。

	f2i v,x,y,z						小数値を整数値に変換

		小数値(X,Y,Z)を整数値に変換して、vで指定された数値型の変数に代入
		します。結果はそれぞれ「v.0=x:v.1=y:v.2=z」の各要素に格納されます。


・DirectXの使用について

	DirectXを使用する場合は、単独のDLL「hgimgx.dll」をお使い下さい。
	また、ヘッダファイルも「hgimgx.as」を使ってください。
	基本的にすべての命令は互換があり、「hgimg.dll」と同様に使用できますが、
	一部制限や装備されていない機能があります。
	DirectX使用時の注意点は以下の通りです。

	・DirectX8以上のランタイムがインストールされている必要があります
	・DirectX使用時は常にフルカラーモードが選択されます
	・テクスチャの縦横サイズは2のn乗(2,4,8,16…)に合わせて読み込まれます
	・現バージョンでは、フルスクリーンモードはサポートされていません
	・現バージョンでは、clstex命令はサポートされていません

	一部のビデオカードでは、テクスチャフォーマットがサポートされていない場合に
	エラーが出ることがあります。hgimgx.dllで、サポートしているテクスチャ形式は、
	「A8R8G8B8」「X8R8G8B8」「A1R5G5B5」「X1R5G5B5」です。テクスチャは、この中
	の最適なフォーマットに変換して使用されます。
	将来のバージョンではインデックスカラーのテクスチャもサポートする予定です。

	DirectX8では、2Dの描画にもDirect3Dのデバイスを使用しています。
	3Dアクセラレーション機能のない一部のビデオカードでは、パフォーマンスが
	出ないことがあります。その場合は、hgimg.dllを使用するか、DirectDrawを
	利用しているhspdx.dllプラグインの方が有利な場合もあります。
	3Dアクセラレーション機能を持つビデオカードでは、hgimg.dllのフルカラー描画時
	と比べて３倍〜５倍程度の高速処理を見込むことができます。

	ver2.61同梱のhgimgx.dllから、Zバッファを使用した描画に切り替わっています。
	これにより、ポリゴンが欠けることがなく、テクスチャの歪みもない描画となります。
	しかし、3Dの演算をDirectXに任せているため、通常(hgimg.dll)の場合とカメラの
	画角や視野範囲に誤差が出ることがありますのでご注意下さい。


・命令リファレンス

	hgini yofs,ysize				DLLの初期化
	hgbye							DLLの開放

		HGIMGの初期化と解放を行ないます。


	hgsrc							ソースバッファ指定

		(未使用)


	hgdst mode						転送先バッファ指定

		画面拡大モード時に転送する先のウインドゥを指定します。
		modeは拡大する種類を示します。


	hgdraw							描画の実行

		全描画を実行します。


	getsync val,mode				時間待ち情報を取得

		val  = 情報が代入される変数名
		mode = 取得モード( 0=現在のタイマ / 1=タイマ分解能 )

		modeで指定した種類の情報を取得します。


	hgsync val						時間待ちを行なう

		val = 待ち時間

		valで指定した時間(ms)だけウェイトを取ります。
		hgsyncは、必ずhgdrawと対にして使用する必要があります。
		hgsyncでウェイトを入れた場合は、指定した待ち時間を過ぎると
		描画をキャンセルして次のフレームの処理を行ないます。


	sync val						時間待ちを行なう

		val = 待ち時間

		valで指定した時間(ms)だけウェイトを取ります。


	getdebug val					デバッグ情報取得

		val = デバッグ情報が代入される変数名


	hgsetreq type,val				システムリクエスト設定
	hggetreq val,type				システムリクエスト取得

		HGIMG.DLLに対して様々なシステム設定を行ないます。
		type値で指定できるのは以下のシンボルです。

			シンボル名         値   内容
		-----------------------------------------------
			SYSREQ_NONE			0	(未使用)
			SYSREQ_MAXMODEL 	1	モデルの最大値(標準4096)
			SYSREQ_MAXOBJ		2	オブジェクトの最大値(標準512)
			SYSREQ_MAXTEX		3	テクスチャの最大値(*)(標準512)
			SYSREQ_MAXMOC		4	MOC登録数の最大値(*)
			SYSREQ_DXMODE		5	DirectXモード
			SYSREQ_DXHWND		6	DirectXモードWNDハンドル
			SYSREQ_DXWIDTH		7	フルスクリーン時Xサイズ
			SYSREQ_DXHEIGHT 	8	フルスクリーン時Yサイズ
			SYSREQ_COLORKEY 	9	透明抜き色となるRGB値
			SYSREQ_PKTSIZE  	12	描画パケットサイズ(標準$100000)

			(*)は現バージョンではサポートされていません

			例:
				;	透明抜き色をRGB=($00,$ff,$ff)とする
				;	(texload命令の直前に使用可能)
				hgsetreq SYSREQ_COLORKEY, $00ffff


	setborder sx,sy,sz				オブジェクト有効範囲設定

		( sx,sy,sz ) = ボーダー領域の大きさ

		ボーダー領域(オブジェクト有効範囲)を設定します。
		( 0,0,0 )を中心にした、( sx,sy,sz )サイズの立方体が
		ボーダー領域となります。


	clscolor prm					背景色設定

		背景色を設定します。
		prmはフルカラーおよびDirectXモード時はRGBコード。
		パレットモード時は、パレット番号になります。


	clstex id						背景テクスチャ設定

		背景となるテクスチャのIDを指定します。
		背景テクスチャはtexloadbg命令で読み込む必要があります。
		DirectX使用時は使用できません。


	setfont cx,cy,px,sw				オリジナルフォント定義

		( cx,cy ) : フォント1つあたりのXYサイズ
		  px      : 1文字表示ごとに右に移動するドット数
		  sw      : 0=透明色抜きなし / 1=透明色抜きあり

		fprt命令で表示するためのフォントを設定します。
		使用するテクスチャはこの直後に読み込まれたものになります。

		例:
			;	テクスチャフォント表示の準備
			;
			setfont 16,16,12,1	; font Tex select(cx,cy,px,mode)
			texload "fontchr.bmp"	; フォントテクスチャの登録


	fprt "mes",x,y					定義フォント文字列表示

		"mes"  : 表示する文字列
		( x,y ) : 表示する座標

		"mes"の内容を指定されたフォントで画面に表示します。
		必ずhgdraw命令と、hgsync命令の間に使用してください。
		(x,y)の指定は画面の左上が(0,0)になります。

		例:
			;	描画メイン
			;
			hgdraw				; 描画処理
			getsync t1,0			; 前回からの負荷を取得
			fprt "HGIMG Plugin test",8,108
			fprt "T:"+t1,8,124
			hgsync 10			; 処理落ちしてなければ描画


	objset1 ofs,x					MOC情報を設定
	objadd1 ofs,x					MOC情報を加算
	objmov1 ofs,times,x				MOC移動情報を設定
	objsetf1 ofs,x					MOC情報を設定
	objaddf1 ofs,x					MOC情報を加算
	objmovf1 ofs,times,x			MOC移動情報を設定
	objset1r ofs,x					MOC情報を設定
	objmov1r ofs,times,x			MOC移動情報を設定

	objset2 ofs,x,y					MOC情報を設定
	objadd2 ofs,x,y					MOC情報を加算
	objmov2 ofs,times,x,y			MOC移動情報を設定
	objsetf2 ofs,x,y				MOC情報を設定
	objaddf2 ofs,x,y				MOC情報を加算
	objmovf2 ofs,times,x,y			MOC移動情報を設定
	objset2r ofs,x,y				MOC情報を設定
	objmov2r ofs,times,x,y			MOC移動情報を設定

	objset3 x,y,z					MOC情報を設定
	objadd3 x,y,z					MOC情報を加算
	objmov3 times,x,y,z				MOC移動情報を設定
	objsetf3 x,y,z					MOC情報を設定
	objaddf3 x,y,z					MOC情報を加算
	objmovf3 times,x,y,z			MOC移動情報を設定
	objset3r x,y,z					MOC情報を設定
	objmov3r times,x,y,z			MOC移動情報を設定

		MOC情報を設定、加算、変化させます。
		fのあるものは、floatでパラメータを指定します。
		最後の数字は連続して設定するパラメータの数です。
		objmov〜は、timesで示したフレーム後に指定した値に変わる
		ように変化情報を設定します。
		最後にrのついた命令は、角度情報を設定するためのものです。
		整数値(256で１回転)をラジアン単位に変換してパラメーターを書き込みます。


	objcheck val					移動の終了を検知

		val  = 情報が代入される変数名

		MOCの変化状態(objmovなどで指定するもの)か、停止
		状態かを取得します。valに代入される値が0の場合は、
		変化中、それ以外の場合は停止中です。
		あらかじめ対象となるMOCを選択しておく必要があります。


	objmovmode mode					MOC移動モード設定

		mode = 補間モード

		MOCのグループに対して補間モードを設定します。
		ここで補間モードに使用できるのは、以下の通りです。

		OBJMOV_STATIC		値変化なし
		OBJMOV_LINEAR		直線補間
		OBJMOV_SPLINE		スプライン補間

		例:
			objmovmode OBJMOV_SPLINE	; スプライン補間モードを選択


	objmovopt ofs,opt				MOC移動オプション設定

		MOCに対して移動オプションを設定します。


	selmoc id, mocofs				MOC情報を設定
	selpos id						移動座標をMOC情報に設定
	selang id						回転角度をMOC情報に設定
	selscale id						スケールをMOC情報に設定
	seldir id						移動量をMOC情報に設定
	selefx id						オブジェクト特殊効果をMOC情報に設定

		MOC設定命令の対象となるMOCグループを指定します。
		idは、オブジェクトIDとなります。


	cammode mode					カメラモードの設定

		mode = モード値

		カメラの向きについてのモードを設定します。
		指定できるモードは、
		CAM_MODE_NORMAL			(カメラの位置、角度に従う)
		と、
		CAM_MODE_LOOKAT			(カメラは注視点を常に向いている)
		です。


	selcam ofs						カメラをMOC情報に設定
	selcpos							カメラ座標をMOC情報に設定
	selcang							カメラ角度をMOC情報に設定
	selcint							カメラ注視点をMOC情報に設定

		MOC設定命令の対象となるMOCグループ(カメラ系)を指定します。

	sellight id,ofs					光源をMOC情報に設定
	sellpos	id						光源座標をMOC情報に設定
	sellang	id						光源角度をMOC情報に設定
	sellcolor id					光源注視点をMOC情報に設定

		MOC設定命令の対象となるMOCグループ(光源系)を指定します。
		idは、光源のID(0〜3)となります。

	objgetfv fv						MOC情報を取得

		MOCに設定されている値を変数fvに代入します。


	objsetfv fv						MOC情報を設定

		変数fvの内容をMOCに設定します。


	objaddfv fv						MOC情報を加算

		変数fvの内容をMOCに加算します。


	objmovfv fv,times				MOC移動情報を設定

		timesフレーム後に変数fvの内容になるように
		MOC変化値を設定します。


	objgetv v						MOC情報を整数値で取得

		MOCに設定されている値を変数fvに整数で代入します。


	objsetv v						MOC情報を整数値で設定

		変数fvに整数で代入されている値をMOCに設定します。


	objgetstr sval					MOC情報を文字列で取得

		sval  = 文字列が代入される変数名

		MOCに設定されている値を変数svalに文字列で書き出します。


	setuv tx0,ty0,tx1,ty1			登録テクスチャUV座標を指定

		(tx0,ty0) : テクスチャの左上座標
		(tx1,ty1) : テクスチャの右下座標

		登録の際に使用されるUV値を指定します。


	setsizef sx,sy					登録モデルの幅、高さを指定

		(sx,sy) : X,Yサイズ(float値)

		登録の際に使用されるサイズ値を指定します。


	setbg sx,sy,cx,cy				BGマップ情報設定

		(sx,sy) : マップX,Yサイズ
		(cx,cy) : チップX,Yサイズ

		マップのサイズと、チップサイズを指定します。


	getbg val,modelID				BGマップを取得

		val     : クローンが作成される変数名
		modelID : モデルID

		BGマップに割り当てられたメモリ空間を変数valに
		クローンで割り当てます。
		以降は、変数valのメモリ空間としてBGマップを書き換える
		ことができます。


	setmap modelID,x,y				BGマップスクロール指定

		(x,y)   : 左上の座標
		modelID : モデルID

		BGマップでウインドゥ内に表示される左上のマップ座標を
		指定します。


	addbox val,mode					箱(BOX)モデルを作成

		val     : 作成されたモデルIDが代入される変数名
		mode    : 0 = 透明色抜きなし / 1 = 透明色抜きあり
		        : +2 = 光源計算あり

		(0,0,0)を中心とする箱(BOX)モデルを作成します。
		サイズは、あらかじめsetsizef命令で設定された大きさになります。
		テクスチャを使用する場合は、setuv命令でテクスチャのUV座標を指定
		しておいて下さい。テクスチャIDは、この直後にtexload命令で登録
		されたものが使用されます。
		単色ポリゴンを使用する場合は、setcolor命令で色を指定しておいて
		下さい。


	addplate val, mode				板(PLATE)モデルを作成

		val     : 作成されたモデルIDが代入される変数名
		mode    : 0 = 透明色抜きなし / 1 = 透明色抜きあり
		        : +2 = 光源計算あり

		板(PLATE)モデルを作成します。
		テクスチャを使用する場合は、setuv命令でテクスチャのUV座標を指定
		しておいて下さい。テクスチャIDは、この直後にtexload命令で登録
		されたものが使用されます。
		単色ポリゴンを使用する場合は、setcolor命令で色を指定しておいて
		下さい。
		板モデルは、3D座標上に存在しますが、常に正面を向くポリゴン
		として設定されます。
		正面を向く属性を解除する場合には、setobjmode命令により
		OBJ_TREEフラグをOFFにすることで可能です。以下の例を参照して
		ください。

			例:
				;	PLATEオブジェクトを登録
				setsizef 8.0f, 8.0f	; BOXのXYサイズ
				setuv 0,0,127,127	; テクスチャUV座標
				addplate mdid		; PLATEモデルを作成
				texload "btex.bmp"	; テクスチャの登録
				regobj mychr,mdid	; モデルをオブジェクトとして登録
				setobjmode mychr,OBJ_TREE,1	; 正面向きを解除


	addspr val, mode				2Dスプライトモデルを作成

		val     : 作成されたモデルIDが代入される変数名
		mode    : 0=透明色抜きなし / 1=透明色抜きあり

		2Dスプライトモデルを作成します。


	addbg val, winx, winy, sw		2DBGマップモデルを作成

		winx : ウインドゥに表示するチップの数X
		winy : ウインドゥに表示するチップの数Y
		val  : 作成されたモデルIDが代入される変数名
		sw   : 0 = 透明色抜きなし / 1 = 透明色抜きあり
		     : +2 = 光源計算あり

		2DBGマップモデルを作成します。


	addmesh val, divsizex, divsizey, mode	3DMESHモデルを作成

		val      : 作成されたモデルIDが代入される変数名
		divsizex : メッシュの分割数X
		divsizey : メッシュの分割数Y
		mode    : 0 = 透明色抜きなし / 1 = 透明色抜きあり
		        : +2  = 光源計算あり
		        : +16 = 繰り返しモード

		分割された3Dポリゴンを使った板(MESH)を作成します。
		setuv、setsizeで指定された情報をもとにモデルを作成します。
		基本的にaddplateで作られる板と同じですが、divsizex × divsizey
		のポリゴンに分割されています。地面など拡大された場合にパースの
		歪みが起こるモデルなどで使用します。
		modeが16の場合は、指定されたテクスチャを1ポリゴンごとに割り付ける
		繰り返しモードとなります。


	mxload "filename"				モデルファイル読み込み

		"filename"で指定したmx形式のファイルをモデルとして
		読み込みます。
		作成されたモデルIDは、システム変数statに代入されます。


	regobj val,ModelID, mode		オブジェクトの登録

		val      : 作成されたオブジェクトIDが代入される変数名
		modelID  : モデルID
		mode     : モード値

		指定されたモデルを表示するためのオブジェクトを作成します。
		成功すると作成されたオブジェクトIDが変数に代入されます。
		何らかの理由で作成に失敗した場合は、-1が代入されます。

		モードは以下の中から選択します。

			ラベル             |        内容
			--------------------------------------------------------------
			OBJ_HIDE             非表示(画面から消す)
			OBJ_TREE             木属性(Y軸のみ正面を向く)
			OBJ_XFRONT           正面属性(常に画面に正面を向く)
			OBJ_UVANIM           UVアニメーションを行なう
			OBJ_UVANIM_1SHOT     UVアニメーション表示後に消滅する
			OBJ_MOVE             XYZ移動量を有効にする
			OBJ_FLIP             ボーダー領域で反転する
			OBJ_BORDER           ボーダー領域を有効にする
			OBJ_2D               2D表示オブジェクトとして扱う
			OBJ_TIMER            消滅タイマーを有効にする
			OBJ_WIPEBOM          ボーダー領域で爆発オブジェクトに変わる
			OBJ_NOSORT           Zソートを無効にする
			OBJ_GRAVITY          重力制御を有効にする
			OBJ_SKY              常に一番奥に描かれる
			OBJ_GROUND           地面オブジェクトとして描かれる

		複数の項目を同時に選択する場合は、「OBJ_SKY|OBJ_MOVE」のように
		「|」で区切って指定してください。何も指定しない場合は、0にするか
		省略して構いません。
		オブジェクトのモードは、あらかじめデフォルトのモードがモデルの種類に応じて
		設定されているので、通常は特に設定する必要はありません。
		また、setmode命令でモデルにモードを指定した場合は、そのモードが
		オブジェクトにも継承されます。


	delobj ObjID					オブジェクトの削除

		ObjID  : オブジェクトID

		指定されたオブジェクトを削除します。


	setobjm ObjID, ModelID			オブジェクトのモデル設定

		ObjID    : オブジェクトID
		modelID  : モデルID

		指定されたオブジェクトが表示するモデルを変更します。


	objact ObjID, anim				指定アニメーションを開始

		ObjID  : オブジェクトID
		anim   : アニメーションID(-1で停止)

		指定されたオブジェクトのアニメーションを開始します。
		animにマイナスの値(-1)を指定することで、アニメーションを解除(停止)
		させることができます。


	setobjmode id,mode,sw			オブジェクトのモード設定

		ObjID    : オブジェクトID
		mode     : モード値
		sw       : 設定スイッチ

		指定されたオブジェクトのモードを変更します。
		モード値は、regobj命令で指定するものと同様です。
		swは、

			sw = 0 : 指定したモード値を追加
			sw = 1 : 指定したモード値を削除
			sw = 2 : 指定したモード値だけを設定

		のように動作します。


	setcoli id,mygroup,enegroup		オブジェクトのコリジョン設定

		id       : オブジェクトID
		mygroup  : 自分が属するグループ値
		enegroup : 衝突を検出する対象となるグループ値

		オブジェクトに対してコリジョン情報を設定します。
		グループ値は、
		1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768
		の中から1つだけを選択可能です。


	getcoli val,id,distance			オブジェクトのコリジョン判定

		val      : 結果が代入される変数名
		id       : オブジェクトID
		distance : 衝突を検出する範囲(float値)

		指定したオブジェクトが持つコリジョン情報をもとに、その
		オブジェクトが衝突している別なオブジェクトのIDを調べます。
		distanceは、衝突する範囲(半径)をfloat値で指定します。
		衝突が検出された場合は、変数にオブジェクトIDが代入されます。
		何も衝突が検出されなかった場合は、-1が代入されます。


	findobj exmode,group			オブジェクト検索

		exmode  : 検索を除外するモード
		group   : 検索対象グループ値

		指定したグループだけを検索します。
		最初にfindobjを実行して、次にnextobj命令で該当する
		オブジェクトを検索することができます。
		また、exmodeで指定したモード(regobjで指定するモード値)
		は検索から除外されます。


	nextobj val						次のオブジェクト検索

		val      : 結果が代入される変数名

		findobj命令で指定された条件をもとにオブジェクトを
		検索します。検索されると、変数にオブジェクトIDが代入
		されます。検索対象がなくなった時には-1が代入されます。


	uvanim id, wait, times, sw		モデルのUVアニメ設定

		id       : モデルID
		wait     : 1コマごとの待ち時間
		times    : アニメーションコマ数
		sw       : モード(0=繰り返し/1=１回のみ)

		指定したモデルIDにUVアニメーションの設定を付加します。
		UVアニメーションは、指定したモデルのV(y)座標を一定時間
		ごとに縦にずらしていくことで実現します。
		(元のテクスチャには縦方向にアニメーションパターンが連続して
		記録されている必要があります)


	setmode ModelID, mode			モデルのモード設定

		ModelID  : モデルID
		mode     : モード値

		指定したモデルIDにデフォルトのモードを付加します。
		モード値はregobj命令で使用しているものと同様です。


	settimer ModelID, timer			モデルのタイマー設定

		ModelID  : モデルID
		timer    : タイマー値

		指定したモデルIDにタイマー値を付加します。
		タイマー値が設定されたモデルは、regobj命令で画面上に
		発生した後、タイマー値の示すフレーム数が過ぎると自動的に
		消去されます。


	setmtex modelid, nodeid, tex, shade	モデルのテクスチャを設定

		ModelID  : モデルID
		NodeID   : ノードID
		tex      : テクスチャID
		shade    : シェーディングモード

		指定したモデルIDの管理するポリゴン、スプライトなどが
		持つテクスチャID情報を変更します。
		NodeIDは複数のポリゴン情報がある場合に特定するためのIDです。
		NodeIDに-1を指定した場合には、モデル全体に指定したテクスチャを
		設定します。
		テクスチャIDに-1を指定した場合には、テクスチャは張られずに
		単色ポリゴンとなります。
		shadeパラメータで、シェーディングモードを指定することができます。
		これは、modelshadeで指定するものと同様のものをポリゴン単位で
		指定するためのものです。


	getmtex val, modelid, nodeid	モデルのテクスチャを取得

		val      : 結果が代入される変数名
		ModelID  : モデルID
		NodeID   : ノードID

		指定したモデルIDの管理するポリゴン、スプライトなどが
		持つテクスチャID情報を取得します。
		NodeIDは複数のポリゴン情報がある場合に特定するためのIDです。
		モデルに複数のポリゴンが含まれている場合には、0以上の
		ノードIDを使用することができます。


	getnode val, modelID, nodeID	モデルのノード情報を取得

		val      : 結果が代入される変数名
		ModelID  : モデルID
		NodeID   : ノードID

		指定したモデルIDの持つノード情報を変数の持つメモリに
		コピーします。
		ノード情報は、以下の構造体が含まれています。

			// 3Dノード情報
			typedef struct
			{
			short code;				// primitive code
			short attr;				// attribute code (material)
			char color;				// color data
			char color2;			// color data2
			short tex;				// TexID
			short num;				// num of VECTOR
			VECTOR *fv;				// XYZ Vertices
			short num2;				// num of UV
			IAXIS *uv;				// UV Vertices
			void *exdata;			// Extra data field (option)
			} PNODE;


	evmodel eventID, modelID		イベントモデルID設定

		ModelID  : モデルID
		eventID  : イベントID

		指定したイベントIDにモデルIDを設定します。


	copybuf mode					指定バッファに画面コピー

		mode  : コピーモード

		HGIMGの描画先から別なスクリーンに画面を拡大しながら
		コピーします。modeで、コピーの種類を指定します。


	mxsend val						MX形式ファイルをパース
	mxconv val						MX形式ファイルを変換
	mxaconv val						MA形式ファイルを変換
	mxgetpoly val					ポリゴン数を取得
	mxgetname val,id				テクスチャ名を取得

		MXファイルを読み込む際に使われる命令群です。
		通常はmxload命令を使用してください。
		これらの命令は、mxload命令モジュール内で使用されています。


	settex x,y,sw					テクスチャを登録

		(x,y) : テクスチャ登録サイズ
		sw    : テクスチャ登録スイッチ
		        (0=上下補正/1=補正なし)

		現在選択されているウインドゥIDの内容をテクスチャとして
		登録します。
		テクスチャの登録に失敗した場合はシステム変数statが0以外
		になります。
		通常は、texload命令、texloadbg命令によってファイルから
		テクスチャを読み込むようにしてください。


	texload "filename"				テクスチャを登録
	texloadbg "filename"			背景テクスチャを登録

		"filename" : 登録するテクスチャとなる画像ファイル

		画像ファイル"filename"の内容をテクスチャとして登録します。
		画像は、picload命令で使用可能なフォーマットと同じものが利用
		可能です。
		テクスチャの登録に失敗した場合はエラーダイアログが表示され、
		システム変数statが0以外になります。
		あらかじめgettex命令で調べておくことで、登録されたテクスチャIDを
		得ることができます。


	gettex val						テクスチャIDを取得

		次に登録されるものに割り当てられるテクスチャIDを取得します。
		ここで得たテクスチャIDが、次にtexload命令、またはtexloadbg命令、
		settex命令で割り当てたテクスチャと同義になります。


・階層モデルについて

	mx形式など1つのモデルIDに、複数のモデル情報を入れて階層的に管理する
	ことが可能です。
	階層モデルでは、「モデルID」と「モデルサブID」の２つを持ちます。

		モデルID#0 -----+---- モデルサブID#1 ------ モデルサブID#2
		(モデルサブID#0)|
		                +---- モデルサブID#3
		                |
		                +---- モデルサブID#4

	階層モデルは、親子関係、兄弟関係があります。
	最も基点となるモデルは「モデルサブID0」となり、階層ごとに新しい「モデルサブID」
	が振られていきます。
	子は、親の移動や回転などの情報を引き継いだ上で、独自の移動、回転情報を
	持つことができます。兄弟関係は、親の情報を引き継ぐだけになります。
	こうした子(child)、兄弟(sibling)の階層構造はCGソフトなどで一般的に使われている
	モデルの管理方法です。

	モデルを階層化させる利点は、アニメーション(モーション)をつけられることにあります。
	たとえば、人体を手足、頭などバラバラのモデルとして作成して、階層化させることで
	1つの人間モデルとして管理でき、ma形式のアニメーションデータを作成すれば、
	手足などをバラバラに動かすことができるようになります。

	HGIMGでは、addbox,addplate,addmeshおよびdxfloadなどで単一の階層(モデルサブID0
	のみを持つモデル)を主に使用していますが、これらを階層化して繋いでいくことで、
	より高度な3Dモデル操作が可能になります。

	モデルが持つ階層構造一覧を取得するために、gettree命令が用意されています。
	これは、指定されたモデルIDの構造を複数行のテキストとして取得するものです。


・新規命令リファレンス

	clsblur val						ブラー設定

		val : 強度(0〜255)

		擬似ブラー効果を設定します。
		valで設定した強度の値が小さいほど、画面に前のフレームが残像として
		残ります。


	setcolor r,g,b					単色ポリゴン作成設定

		r,g,b : RGB色情報(それぞれ0〜255)

		モデルの作成を行なう際のポリゴン色を設定します。
		addplate,addbox命令などで単色ポリゴンを作成する場合に使用します。


	falpha val						フォント文字α値を設定

		val : フォント表示に使用するα合成値

		fprt命令によるフォント表示で使用されるα合成値を指定します。
		以降すべてのfprt命令に適用されます。
		α値についての詳細は以下の通りです。

			α合成値 = 0〜255    : 背景とα合成(blend)を行なう
			α合成値 = 256〜511  : 合成を行なわない(通常時)
			α合成値 = 512〜767  : 背景と色加算(modulate)を行なう
			α合成値 = 768〜1023 : 背景と色減算(substract)を行なう


	maload "file"					モデルアニメーション読み込み

		"file" : 読み込むファイル名(拡張子なし)

		MA形式で書かれたアニメーション情報ファイルを読み込みます。
		先に、mxload命令によりモデルデータを読み込んでおく必要があります。
		その直後に、対応するアニメーションデータを読み込むことで、
		モデルにアニメーションが関連付けられます。
		複数のアニメーションを1つのモデルに対して読み込むことも可能です。
		maload命令で最初に読み込まれたアニメーションは、ID0となり、次に読み込むと
		ID1…という具合にアニメーションIDが順番に付けられていきます。
		アニメーションの再生は、objact命令によって行ないます。

		例:
			;	MXファイルオブジェクトを登録
			mxload "rb_000"		; モデルファイル読み込み
			model=stat			; 登録されたモデルIDをmodelに代入
			maload "walk"		; アニメーション#0読み込み
			regobj mychr,model	; モデルをオブジェクトに登録
			selpos mychr
			objsetf3 0.0f, 0.0f, 0.0f
			objact mychr,0


	modelmovef id,x,y,z				モデルの絶対位置を移動

		id      : モデルID
		(x,y,z) : X,Y,Z移動値(float値)

		指定したモデルが持つのポリゴン座標データを移動させます。
		これによりモデルの中心座標をずらすことなどが可能になります。


	modelscalef id,x,y,z				モデルの拡大縮小

		id      : モデルID
		(x,y,z) : X,Y,Z倍率(float値)

		指定したモデル全体を指定したスケール値で拡大縮小します。
		これによりモデルそのもののサイズ自体を変えることが可能になります。


	modelshade id,mode,sw			モデルシェーディングモードの設定

		id   : モデルID
		mode : シェーディングモード(0〜7)
		sw   : 法線再計算スイッチ(0=ON/1=OFF)

		モデルのシェーディングモード(光源計算モード)を設定します。
		シェーディングモードにより、リアルタイムに光源計算を行なうことが
		可能になります。
		ただし、速度的な問題からDirectXモードとそれ以外では、サポート
		されない機能もあるので注意してください。
		サポートされる機能は以下の通りです。
		swで法線の再計算をするかどうかを指定することができます。
		swが0の場合は、法線の再計算を行ないます。これは、ポリゴン数に比例して
		時間がかかります。特にグーローシェーディングの場合は、あらかじめ計算済みの
		モデルデータを用意する方が効率的です。
		モードに+4を加算することで、ワイヤーフレーム表示に切り替わります。
		ワイヤーフレーム表示中も、シェーディングモードが反映されます。
		また、テクスチャはワイヤーフレーム表示時は白線(RGB=255)となります。

		・光源計算なし(0)(4)

			通常のHGIMGで使われる状態です。光源計算は特に行なわず、
			指定された色やテクスチャがポリゴンの表面に貼られます。

		・フラットシェーディング(1)(5)

			ポリゴンの面単位で光源計算を行ないます。
			DirectXか、フルカラーの単色ポリゴン時にのみサポートされます。

		・グーローシェーディング(2)(6)

			頂点単位で光源計算を行ないグラデーション処理されます。
			DirectX時にのみサポートされます。

		・高機能グーローシェーディング(3)(7)

			複数の光源をサポートした高度な光源処理を行ないます。
			DirectX時にのみサポートされます。
			現時点ではまだサポートされていません。


		・テクスチャなし(単色)ポリゴン

		| モード  |    パレット  |   フルカラー  |  DirectXフルカラー  |
		----------------------------------------------------------------
		|   0     |      ×      |  光源計算なし |  光源計算なし       |
		|   1     |      ×      |  フラット     |  フラット           |
		|   2     |      ×      |  フラット     |  グーロー           |
		|   3     |      ×      |  フラット     |  高機能グーロー     |
		----------------------------------------------------------------

		・テクスチャありポリゴン

		| モード  |    パレット  |   フルカラー  |  DirectXフルカラー  |
		----------------------------------------------------------------
		|   0     | 光源計算なし |  光源計算なし |  光源計算なし       |
		|   1     | 光源計算なし |  光源計算なし |  フラット           |
		|   2     | 光源計算なし |  光源計算なし |  グーロー           |
		|   3     | 光源計算なし |  光源計算なし |  高機能グーロー     |
		----------------------------------------------------------------


	dxfload "file"					DXF形式ファイルを読み込み

		"file" : ファイル名(拡張なし)

		DXF形式のファイルをモデルデータとして読み込みます。
		システム変数statに読み込まれた先のモデルIDが返されます。
		DXF形式は、CADやほとんどの3Dツールがサポートしている基本的な
		3D形状フォーマットです。テクスチャ情報など高度な情報は反映
		されませんが、形状をやり取りすることが可能です。
		dxfload命令では、DXF形式の3DFACEというタイプにのみ対応しています。
		一部のファイルとは互換がない可能性があります。


	dxfconv val						DXF形式ファイルをパース
	dxfgetpoly val					ポリゴン数を取得

		DXFファイルを読み込む際に使われる命令群です。
		通常はdxfload命令を使用してください。
		これらの命令は、dxfload命令モジュール内で使用されています。


	objscanf2 val,fx,fy				2D座標からポリゴン検索
	objscan2 val,x,y				2D座標からポリゴン検索

		val     : 結果が代入される変数名
		(fx,fy) : 画面上の2D座標(float値)
		(x,y)   : 画面上の2D座標(整数値)

		指定した画面上の2D座標に表示されているポリゴンを特定します。
		結果は、valで指定した変数に代入されます。

		valは、配列変数の情報として以下のものが代入されます。
		あらかじめdim命令で必要なサイズ(32)を確保しておく必要があります。

			例:
				dim scan,32
				objscan2 scan,mousex,mousey

		代入される情報
			val.0			; Scan ObjID ( -1=情報なし )
			val.1			; Scan ModelID
			val.2			; Scan SubModelID
			val.3			; Scan NodeID
			val.4			; Scan Z-OT
			val.5			; Scan Mode (0=2DPoint/1=3DLine)
			val.6〜val.9	; Scan Result(float x,y,z,w) (Collision Point)
			val.10〜val.13	; Scan target point (float x,y,z,w)
			val.14〜val.17	; Scan target vector (float x,y,z,w)


	setmchild model_id,sub_id,id	階層の子を設定
	setmsibling model_id,sub_id,id	階層の兄弟を設定

		model_id : 設定元モデルID
		sub_id   : 設定元モデルサブID
		id       : 追加モデルID

		階層構造に子、兄弟を追加します。


	getmchild val,id,sub_id			指定した階層の子を取得
	getmsibling val,id,sub_id		指定した階層の兄弟を取得

		val      : 結果が代入される変数名
		id       : モデルID
		sub_id   : モデルサブID

		指定したモデル階層が持つ、子、兄弟のサブIDを取得します。
		結果は、valで指定した変数に代入されます。


	setmfv fv,model_id,sub_id,type	階層パラメータを設定
	getmfv fv,model_id,sub_id,type	階層パラメータを取得

		fv       : FV値が代入されている変数名
		model_id : モデルID
		sub_id   : モデルサブID
		type     : タイプID

		指定した階層にFV値を設定します。
		タイプIDで指定できるものは以下の通りです。

			   タイプID   |
			-------------------------------------------
			        0     |  階層の移動(trans)
			        1     |  階層の角度(angle)
			        2     |  階層のスケール(scale)


	getmodel val,model_id,sub_id	モデル情報を読み出し
	putmodel val,model_id,sub_id	モデル情報を書き出し

		val      : 情報が代入される変数名
		model_id : モデルID
		sub_id   : モデルサブID

		モデル情報の読み書きを行ないます。

			// シーンモデル情報
			typedef struct
			{
			VECTOR pos;				// local Position
			VECTOR ang;				// local Angle
			VECTOR scale;			// local Scale
			short id;				// Model ID
			short opt;				// option (no use)
			short num;				// num of NODE
			short nummax;			// Maximum num of NODE(0=none)
			PNODE **node;			// Node ptr
			void *sibling;			// Sibling Object
			void *child;			// Child Object
			float bound;			// Bounding Box Max Length
			
			short aindex;			// Animation Max Index ( 0 = No Anim)
			short anum;				// Animation Frame Max ( 0 = No Anim )
			ANMINF *ani;			// Animation Data Array (option)
			short anifr[16];		// Animation Frame Start Index (option)
			short animax[16];		// Animation Frame Max Index (option)
			} MODEL;


	dupnode val,ID,subID,nodeID		ノード情報へのクローンを作成

		val      : クローンを作成する変数名
		modelID  : モデルID
		subID    : モデルサブID
		nodeID   : ノードID

		指定されたノード情報を参照する変数のクローンを作成します。
		3Dのノードは、Cの構造体で以下の内容が格納されています。

			// 3Dノード情報
			typedef struct
			{
			short code;				// primitive code
			short attr;				// attribute code (material)
			int color;				// color data
			short tex;				// TexID
			short num;				// num of VECTOR
			VECTOR *fv;				// XYZ Vertices
			VECTOR *fn;				// XYZ Normals
			short num2;				// num of UV
			IAXIS *uv;				// UV Vertices
			void *exdata;			// Extra data field (option)
			} PNODE;


	mxsave "file",id				指定モデルをMX形式で出力

		"file" : ファイル名(拡張子含む)
		id     : モデルID

		指定したモデルIDの情報をMX形式のファイルとして書き出します。
		テクスチャがある場合には、あらかじめmxtex命令でテクスチャリストを
		指定しておく必要があります。


	mxtex val						MX形式出力時のテクスチャリスト登録

		val : テクスチャリストが格納されている変数

		mxsave命令でMX形式のファイル書き出しを行なう場合に、テクスチャ
		情報を付加します。
		valで指定した文字列型変数に、複数行のテキストデータとして、
		テクスチャのファイル名(拡張子なし)を指定することで、MXファイル内に
		情報が格納されます。
		テクスチャリストは、１行目がテクスチャID0になり、以降１行ごとにIDが
		振られていきます。


	gettree val,id					指定モデル階層構造をテキストで取得

		val : 情報が代入される変数名
		id  : モデルID

		指定されたモデルIDが持つ階層構造の情報を複数行テキストの形で取得します。
		valで文字列型の変数を指定することで、idのモデル情報が代入されます。
		取得されたテキストは、関連モデルのサブIDが行ごとに示され、深い階層に
		なるほど行頭にスペースが挿入されます。これにより、子供のモデルか、兄弟の
		モデルであることを知ることができます。

			例:
				mxload s1		; モデルファイル読み込み
				model = stat	; (変数statにモデルIDが返される)
				sdim mdltree,256
				gettree mdltree,model
				mes mdltree

			取得例:
				(1)
				 (2)
				  (3)
				(4)


	hgreset							シーン情報の初期化

		シーンの情報の初期化を行ないます。
		すべてのモデル、オブジェクト、テクスチャなどの情報は破棄され、
		まったく新しいシーンの状態に戻します。


	setmuv val,model_id,node_id		UV情報の設定

		val       : 情報が代入されている変数名
		model_id  : モデルID
		node_id   : ノードID

		ポリゴン単位のUV値を設定します。
		model_idで指定されたモデル内の、node_idで指定されたポリゴンが
		持つUV値をvalで指定された変数のものに設定します。
		ポリゴンは４角形の情報が保存されています。valは、配列変数に
		格納された整数値で、以下のように設定されます。

			val.0 , val.1	UV0
			val.2 , val.3	UV1
			val.4 , val.5	UV2
			val.6 , val.7	UV3


	getmuv val,model_id,node_id		UV情報の取得

		val       : 情報が代入される変数名
		model_id  : モデルID
		node_id   : ノードID

		ポリゴン単位のUV値を取得します。
		model_idで指定されたモデル内の、node_idで指定されたポリゴンが
		持つUV値をvalで指定された変数に読み出します。
		ポリゴンは４角形の情報が保存されています。valは、配列変数に
		格納された整数値で、以下のように設定されます。

			val.0 , val.1	UV0
			val.2 , val.3	UV1
			val.4 , val.5	UV2
			val.6 , val.7	UV3


	nodemax val,model_id,sub_id		ノード情報の数を取得

		val      : 情報が代入される変数名
		model_id : モデルID
		sub_id   : モデルサブID

		指定されたモデルが持つノード数を取得します。
		モデルが持つノードIDは、0〜(ノード数-1)になります。


	setmpoly val,id,node_id,mode	ポリゴン頂点情報の設定

		val      : 頂点情報が代入されている変数名
		model_id : モデルID
		node_id  : ノードID
		mode     : 頂点の種類(0=座標/1=法線)

		ポリゴン単位の頂点情報を設定します。
		model_idで指定されたモデル内の、node_idで指定されたポリゴンが
		持つ頂点情報をvalで指定された変数値で書き込みます。
		変数valは、浮動小数値が格納される配列変数となります。

			val.0 , val.1 , val.2 , val.3	頂点1(X,Y,Z,W)
			val.4 , val.5 , val.6 , val.7	頂点2(X,Y,Z,W)
			val.8 , val.9 , val.10, val.11	頂点3(X,Y,Z,W)
			val.12, val.13, val.14, val.15	頂点4(X,Y,Z,W)

		modeで、頂点の種類(0=座標/1=法線)を指定することが可能です。


	setmpoly val,id,node_id,mode	ポリゴン頂点情報の取得

		val      : 頂点情報が代入される変数名
		model_id : モデルID
		node_id  : ノードID
		mode     : 頂点の種類(0=座標/1=法線)

		ポリゴン単位の頂点情報を取得します。
		model_idで指定されたモデル内の、node_idで指定されたポリゴンが
		持つ頂点情報をvalで指定された変数に読み出します。
		変数valは、浮動小数値が格納される配列変数となります。

			val.0 , val.1 , val.2 , val.3	頂点1(X,Y,Z,W)
			val.4 , val.5 , val.6 , val.7	頂点2(X,Y,Z,W)
			val.8 , val.9 , val.10, val.11	頂点3(X,Y,Z,W)
			val.12, val.13, val.14, val.15	頂点4(X,Y,Z,W)

		modeで、頂点の種類(0=座標/1=法線)を指定することが可能です。


・DirectXフルスクリーンモードについて

	hgsetreq命令によって、SYSREQ_DXMODEのモードに1を指定することで、
	hgini命令で初期化した際にフルスクリーンモードが選択されます。
	フルスクリーン時の解像度は、SYSREQ_DXWIDTH、SYSREQ_DXHEIGHTで指定します。
	現時点では、フルスクリーンとウインドゥモードの動的な切り替えはサポート
	していません。

		例:

		;	初期設定
		;
		bgscr 2,640,480,0		; フルスクリーンは必ずbgscrで作成
		cls 4
		hgsetreq SYSREQ_DXMODE,1		; フルスクリーンモードを指定
		hgsetreq SYSREQ_DXWIDTH,640		; フルスクリーン解像度X
		hgsetreq SYSREQ_DXHEIGHT,480	; フルスクリーン解像度Y
		hgini


・光源の設定ついて

	ver2.0β2から光源の設定をサポートしています。
	MOC設定命令の一部として、sellight,sellpos,sellang,sellcolorなどが
	用意されています。
	これにより、光源の位置、角度、色、アンビエント色などを指定できるように
	なっています。
	詳しくは、「MOC設定命令について」の項をお読みください。
	また、光源計算を行なうオプションが各種モデル作成命令(addbox,addplate,
	addmesh)に追加されているほか、単色ポリゴンを使用したモデル作成のための
	setcolor命令が追加されています。


・α合成モードについて

	ver2.0β2からα値による画像の合成(半透明)表示をサポートしています。
	α合成は、シェーディング、2D、3Dの区別なく高い精度で処理されます。
	DirectX、フルカラーモード時以外でのみサポートされます。
	オブジェクトの合成パラメータを設定するためのselefx命令が追加されて
	います。この命令により、オフセット0にα合成値を設定することで、任意の
	合成をオブジェクト全体に対して適用することができます。

			α合成値 = 0〜255    : 背景とα合成(blend)を行なう
			α合成値 = 256〜511  : 合成を行なわない(通常時)
			α合成値 = 512〜767  : 背景と色加算(modulate)を行なう
			α合成値 = 768〜1023 : 背景と色減算(substract)を行なう

		例:
			selefx obj_id
			objsetf1 0,128	; 50%合成

	詳しくは、「MOC設定命令について」の項をお読みください。
	また、fprt命令でフォント表示を行なう際のα値を指定するfalpha命令も
	追加されています。詳しくはリファレンスを参照してください。


・ワイヤーフレーム表示モードについて

	ver2.0β2からワイヤーフレーム(線画)による描画をサポートしています。
	通常のポリゴンモデルを線で繋いだ状態で表示します。
	詳しくはmodelshade命令のリファレンスを参照してください。


・新規MOC設定命令について

	ver2.0β2から以下のMOC設定命令が追加されています。

		objset1r ofs,x					MOC情報を設定
		objmov1r ofs,times,x			MOC移動情報を設定
		objset2r ofs,x,y				MOC情報を設定
		objmov2r ofs,times,x,y			MOC移動情報を設定
		objset3r x,y,z					MOC情報を設定
		objmov3r times,x,y,z			MOC移動情報を設定

	これらの命令は、回転情報のパラメーターを整数で指定するためのものです。
	整数値0〜255までを１周とする単位で扱うことができます。
	たとえば、180度回転する場合ラジアンでは、いままでは、

		selang id
		objsetf1 0,3.141592f	; 半回転

	のように指定していましたが、かわりに

		selang id
		objset1r 0,128			; 半回転

	と指定することができます。set(情報の書き込み)のほか、mov(移動設定)も
	指定することが可能です。
	これにより、直感的にわかりにくかった角度を256単位(１６進数で$100)で
	扱うことができ役立つ場合があります。また、主なパラメーターをすべて
	整数で扱うことができるので、HSPスクリプトからのコントロールが容易になります。


・MXファイルフォーマットについて

	MXファイルは、HGIMGで扱うことのできるポリゴンモデル記述	ファイルです。
	MXファイルへの変換や、加工などのサポートは今後順次リリースしていく予定です。
	ver2.0β2からマテリアル情報エリアなどが追加されたMXフォーマットver2.0が
	定められました。以前のバージョンからの上位互換となっています。

	現在、以下のサイトでMXフォーマットを扱うツールを製作、配布しています。

	[ONION software]
	http://www.onionsoft.net/hsp/

	XtoMXコンバーターを公開しています。DirectX8のX形式から、HGIMGで扱うことが
	できるmx形式に変換します。テクスチャやUV情報なども含めて有効な情報が変換
	されます。

	[よし〜ふ ゲーム開発部屋]
	http://member.nifty.ne.jp/Yoshirf/

	「YJ Studio 2001　モデリング編集」ツールで、ポリゴンのモデリング編集
	およびテクスチャの設定、MXフォーマットの読み書きをサポートしています。
	また、「ＹＪＰコンバータ」を使用することで、YJP形式を通して、DXF形式、
	X形式(DirectX)、LWO形式(Lightwave3D)、ROK形式(六角大王)からのモデル
	データ変換を行なうことが可能です。

	[MIA's HomePage]
	http://www.diry.net/mia/

	MQO -> MX コンバータを公開しています。MQO形式は、3Dモデリングツール
	Metasequoia が出力するファイル形式です。テクスチャやUV情報なども含めて
	有効な情報が変換されます。

	Metasequoiaは、O.Miznoさんが作られた3Dモデリングツールです。
	フリー版のMetasequoiaLEは、オンラインですぐに入手することができ、
	MQO形式データの作成を行なうことが可能です。
	Metasequoia自身や、プラグインでかなり多種のフォーマット読み込みに
	対応しているため既存の3Dファイルからの変換の可能性がぐんと広がります。
	詳しくは、以下のページへどうぞ。

		[Mizno Lab.]
		http://www1.sphere.ne.jp/mizno/

	[3DACE の部屋]
	http://hp.vector.co.jp/authors/VA017881/

	直感的に3Dのモデリングを行うことのできるソフト3DACEを公開しています。
	テクスチャも含めてMX形式での出力に対応しています。

	[Cyberdelia.net]
	http://www.cyberdelia.net/

	高機能モーション編集ソフトCyberdeliaを公開しています。
	MX形式での入出力、アニメーションをMA形式で出力することが可能です。


	・mxフォーマット詳細(ver2.0)

	ユーザー側でMXファイルを作成する場合は、以下のフォーマットに従って
	ファイルを生成していただくようお願い致します。
	MXファイルフォーマットは今後、拡張改編される可能性があります。
	MXファイルについての技術的なご意見やご質問は、メールかβ版の掲示板へ
	お願い致します。

		MXファイル構造(以下の順に各構造体が記録されています)

			[MXHED]
			[MDINF]  ( SIZE_MDINF のバイト数だけ格納されています )
			[NDINF]  ( SIZE_NDINF のバイト数だけ格納されています )
			[MATINF] ( SIZE_MATINF のバイト数だけ格納されています )
			[EMTINF] ( SIZE_EMTINF のバイト数だけ格納されています )

		[MXHED]はヘッダ情報です。以下の内容を持っています。
		h1〜h4は、$4d,$58,$46,$00固定です。
		現在のバージョンは2.00($0200)です。

		typedef struct
		{
			//		MX file header structure (ver2)
			//
			char	h1;					// magic code1
			char	h2;					// magic code2
			char	h3;					// magic code3
			char	h4;					// magic code4
			int		version;			// version number info

			int		size_mdinf;			// size of Model section
			int		pt_mdinf;			// ptr to Model Segment
			int		size_ndinf;			// size of Node section
			int		pt_ndinf;			// ptr to Node Segment
			int		size_matinf;		// size of Matinf section
			int		pt_matinf;			// ptr to Matinf Segment

			//		Additional information
			int		flags;				// Extra Mode Flags
			short	texoffset;			// global Texture ID offset
			short	matoffset;			// global Material ID offset
	
			int		size_emtinf;		// size of ExMatinf section
			int		pt_emtinf;			// ptr to ExMatinf Segment
		} MXHED2;

		flagsフィールドには、mxファイルに含まれる情報の設定が保存されます。
		以下のフラグによってON/OFFをコントロールすることができます。
		( (*)がついているものは現状でサポートされていません。)

		#define MX_FLAG_GLOBALTEX 1		// グローバルのTextureIDを使用する
		#define MX_FLAG_UV2	2			// UV値を0.0〜1.0で格納する
		#define MX_FLAG_PCOLOR 4		// 法線の替わりにRGB値を格納する(*)
		#define MX_FLAG_WEIGHT 8		// ndinfのvector.wにボーンウェイト情報を格納する(*)
		#define MX_FLAG_BONE 16			// ndinfのnormal.wにブレンド先ボーン情報を格納する(*)
		#define MX_FLAG_BOUND 32		// mdinfのscale.wにバウンディング半径情報を格納する(*)

		続いてモデル情報を示す構造体が続きます。
		階層構造を持つモデル同士の接続を示しています。
		ndinfが示す[NDINF]のインデックスから、num_ndinfの個数がモデルの
		持つポリゴン情報になります。

		typedef struct
		{
			MX_VECTOR pos;			// トランスレート
			MX_VECTOR ang;			// 角度
			MX_VECTOR scale;		// スケール
			short	flag;			// enable flag ( master model )
			short	num_ndinf;		// num of ndinf
			int		ndinf;			// ndinf index
			short	child;			// 子のmodel index
			short	sibling;		// 兄弟のmodel index
		} MDINF;

		それに続いてポリゴン情報が記録されます。
		NDINFには、すべて４角形ポリゴンとして記録されています。
		３角形の場合は最後の２頂点は同じ座標になります。
		UV座標はfloat値ですが、テクスチャ上の座標値(ドット単位)となります。
		ただし、MX_FLAG_UV2が指定されている場合、UV値はテクスチャ上の仮想座標
		(0.0〜1.0)になります。
		MX_VECTOR型のwは、通常は1.0fです。

		typedef struct {
		  float x, y, z, w;
		} MX_VECTOR;

		// 整数AXIS型
		typedef struct {
		float u,v;
		} MX_UVAXIS;

		typedef struct
		{
			MX_VECTOR v[4];			// 頂点座標
			MX_VECTOR n[4];			// 法線
			MX_UVAXIS uv[4];		// UV座標
			int color;				// ディフューズ色(R8G8B8)
			short tex;				// テクスチャID(-1の場合はテクスチャなし)
			short mat;				// マテリアル情報
		} NDINF;

		matフィールド(マテリアル情報)は、以下のフラグが格納されます。

		#define NODE_ATTR_COLKEY 0x8000
		#define NODE_ATTR_USEMATERIAL 0x400	// MaterialID(bit0-10)を参照する
		#define NODE_ATTR_GLOBALMAT 0x800	// グローバルのMaterialIDを使用する
		#define NODE_ATTR_SHADE_NONE 0
		#define NODE_ATTR_SHADE_FLAT 1
		#define NODE_ATTR_SHADE_GOURAUD 2
		#define NODE_ATTR_SHADE_WIREFRAME 4

		通常は、シェーディングモード(0=光源計算なし/1=フラット/2=グーロー)が
		指定されますが、NODE_ATTR_USEMATERIALフラグをONの時は、bit0〜10で指定
		された値はマテリアルID(EMTINFバッファ内の順番を示すID)となり、より
		細かい質感設定が可能になります。
		NODE_ATTR_COLKEYフラグがONの時は、テクスチャマッピングの際にカラーキー
		(透明色)のドットは転送されなくなります。


		次にテクスチャのファイル名(拡張子なし)がascii文字列で
		記録されています。

		typedef struct
		{
			char name[16];			// テクスチャのファイル名
		} MATINF;


		次にマテリアル定義の拡張用バッファが記録されています。

		typedef struct
		{
			//	Extra Material Info
			//
			short	flag;			// Mode Flags
			char	shade;			// Shade Mode (0=no light/1=flat/2=gouraud)
			char	priority;		// Transparent priority
			int		opt1;			// (option)
			int		opt2;			// (option)
			float	alpha;			// 0.0〜1.0 透明 / 1.1〜 加算 / -0.1〜 減算

			float	diffuse;		// diffuse rate値(0.0〜1.0)
			float	fog;			// fog rate値(0.0〜1.0)
			float	specular;		// スペキュラーrate値(0.0〜)
			float	envmap;			// 環境マップrate値(0.0〜1.0)

			float	pad[8];			// (reserved)
		} EMTINF;

		現状では、shadeフィールド以外はサポートされていません。


・MAファイルフォーマットについて

	MAファイルは、HGIMGで扱うことのできるモデルアニメーション記述ファイルです。
	MAファイルへの変換や、加工などのサポートは今後リリースされる予定です。

	MAファイルは、テキスト形式で行単位にデータを解釈します。
	頭が「;」で始まる行はコメントとみなされます。

		1つのセクションは、「*????」で始まる(????はモデル階層を示すサブID数値)
		(例「*0001」)

		続いて、

		s x,y,z (スケール)
		r x,y,z (角度)
		t x,y,z (移動)

		以上のセットが1フレームのキーとなります。
		このセットをフレーム数だけ続けて記述します。
		x,y,zはfloat値で記述します。
		モーションの終了は、

		go back で先頭のフレームに戻る
		end     でアニメーション終了

		のどちらかになります。
		以上が1つのセクション(モデル階層)となります。
		フレームの数はセクションごとに異なっていて構いません。

	データの例:(実際には先頭にTABは含みません)
		*0001_wak1			; 0rb_009(25Keys)
		s 1.000000,1.000000,1.000000
		r 0.000000,0.000000,0.000000
		t 0.000000,0.000000,0.000000
		s 1.000000,1.000000,1.000000
		r 0.000000,0.000000,0.000000
		t 0.000000,-0.086399,0.000000
		s 1.000000,1.000000,1.000000
		r 0.000000,0.000000,0.000000
		t 0.000000,-0.347900,0.000000
		go back


・DirectXモードと、通常描画モードの違いについて(new)

	HGIMG 2.61版から、DirectX(hgimgx.as)使用時に、3D座標変換をDirectXの
	システム側で行なうように修正されました。
	これにより、透視変換の工程で通常描画(hgimg.as)時と若干の差異が生じます。
	今まで、HGIMGではDirectX使用時もそうでない時も、まったく同じカメラの
	ビューを提供していましたが、2.61版からは視野や画角に多少の違いがある
	ことをご了承下さい。

	また、DirectX使用時には、Zバッファを使用するため、通常描画に比べて
	ちらつきのない表示とパースペクティブコレクト(歪みのない)テクスチャ
	表示が行なわれます。


・パケットサイズについて(new)

	HGIMG 2.61版から、パケットサイズの指定を行なうことが可能になりました。
	パケットメモリは、画面上にオブジェクトを表示する場合に必要とされる
	一時的な領域です。モデルの数が少なくても、多くのオブジェクトを画面に
	表示しようとすると、多くのメモリが必要となります。
	パケットサイズは、そのメモリ量を設定します。
	以下は、パケットサイズを$200000に設定する例です。

	hgsetreq SYSREQ_PKTSIZE,$200000	; パケットサイズを拡張する

	パケットサイズは、標準で$100000が割り当てられています。
	標準サイズで、表示しきれなくなる場合や、エラーが発生する場合には
	パケットサイズを調整してみてください。
	hgsetreq命令によるパケットサイズ拡張は、hgini命令を実行する前に
	行なう必要があるので注意してください。(パケットサイズ設定後に
	hgini命令が実行されないと設定が反映されません。)

	また、表示するオブジェクト(およびMOC数)が足りない場合は、別途
	SYSREQ_MAXOBJによりオブジェクト最大数を設定する必要があります。
	以下の例は、オブジェクト最大数を1024に設定します。

	hgsetreq SYSREQ_MAXOBJ,1024	; オブジェクト最大数を拡張する

	オブジェクト最大数は、標準で512が割り当てられています。
	オブジェクト最大数と、パケットサイズは同じ意味ではありません。
	オブジェクト最大数が少ない場合でも、ポリゴン数の多いモデルを多数
	表示しようとすれば、パケットサイズが多く必要になりますし、逆に
	ポリゴン数の少ないモデルであれば、オブジェクト数が多くなっても
	パケットサイズは消費しません。
	つまり、パケットサイズは画面上に表示される総ポリゴン数に比例する
	もので、オブジェクト最大数は単純にオブジェクトを登録することが
	できる限界値を示しています。


-------------------------------------------------------------------------------
                                                HSP users manual / end of file 
-------------------------------------------------------------------------------
